---
title: "Classes"
phase: 2
order: 5
requires: []
prev: "2.4_functions"
next: "3.1_files"
---

# Lesson 6: Classes and Objects

## The Problem

You've been using dictionaries to represent stocks: `{"symbol": "AAPL", "price": 175}`. But there's no enforcement—you could accidentally write `{"symboll": "AAPL"}` (typo) or forget the price entirely. And what about behavior? A stock should be able to calculate its value, but dictionaries don't have methods specific to stocks.

You need a way to **bundle data and behavior together** with a clear structure.

---

## The Metaphor

A **class** is like a **blueprint** for a house:
- It defines what every house of this type has (rooms, doors, windows)
- It defines what every house can do (open doors, turn on lights)
- The blueprint itself isn't a house—it's instructions for making houses

An **object** (or **instance**) is an actual house built from that blueprint:
- Each house has its own specific values (3 bedrooms, blue door)
- Each house can do the same things (open its specific door)
- You can build many houses from one blueprint

---

## The Technical Reality

### Everything Is an Object

In Python, everything you've used is already an object:

~~~python runnable
x = 42
print(type(x))         # <class 'int'>
print(x.bit_length())  # 6 (method on int object)

s = "hello"
print(type(s))         # <class 'str'>
print(s.upper())       # "HELLO" (method on str object)

# Even functions are objects
def greet():
    pass
print(type(greet))     # <class 'function'>
~~~

Classes let you define your **own** types of objects.

### Attributes and Methods

- **Attributes**: data stored in an object (like `stock.price`)
- **Methods**: functions that belong to an object (like `stock.calculate_value()`)

```
Object (instance of Stock)
├── Attributes (data)
│   ├── symbol = "AAPL"
│   ├── price = 175.50
│   └── shares = 100
└── Methods (behavior)
    ├── calculate_value()
    ├── profit_loss()
    └── __str__()
```

### The `self` Parameter

Every method receives `self` as its first parameter—a reference to the specific object calling the method:

~~~python runnable
class Stock:
    def calculate_value(self):
        # self.shares refers to THIS stock's shares
        return self.shares * self.price

aapl = Stock()
aapl.shares = 100
aapl.price = 175

# When you call:
print(aapl.calculate_value())
# Python actually calls:
print(Stock.calculate_value(aapl))
~~~

---

## The Code

### Defining a Class

~~~python runnable
class Stock:
    """Represents a stock position."""

    def __init__(self, symbol, shares, price):
        """
        Initialize a stock position.

        Parameters
        ----------
        symbol : str
            Stock ticker symbol
        shares : int
            Number of shares owned
        price : float
            Current price per share
        """
        self.symbol = symbol
        self.shares = shares
        self.price = price

    def value(self):
        """Calculate total position value."""
        return self.shares * self.price

    def __str__(self):
        """String representation for print()."""
        return f"{self.symbol}: {self.shares} shares @ ${self.price:.2f}"

    def __repr__(self):
        """Developer representation for debugging."""
        return f"Stock('{self.symbol}', {self.shares}, {self.price})"


# Creating instances
aapl = Stock("AAPL", 100, 175.50)
googl = Stock("GOOGL", 50, 140.25)

# Using attributes and methods
print(aapl.symbol)       # "AAPL"
print(aapl.value())      # 17550.0
print(aapl)              # "AAPL: 100 shares @ $175.50"
print(repr(aapl))        # "Stock('AAPL', 100, 175.50)"
~~~

### The `__init__` Method

`__init__` is called automatically when you create an instance. It's for setting up initial state:

~~~python runnable
class Portfolio:
    def __init__(self, name, initial_cash=0):
        self.name = name
        self.cash = initial_cash
        self.holdings = {}  # Empty dict for stocks

portfolio = Portfolio("Retirement", 10000)
print(portfolio.name)   # "Retirement"
print(portfolio.cash)   # 10000
~~~

### Instance vs Class Attributes

~~~python runnable
class Stock:
    # Class attribute - shared by ALL instances
    exchange = "NYSE"

    def __init__(self, symbol, price):
        # Instance attributes - unique to each instance
        self.symbol = symbol
        self.price = price

aapl = Stock("AAPL", 175)
googl = Stock("GOOGL", 140)

# Instance attributes are separate
print(aapl.price)    # 175
print(googl.price)   # 140

# Class attribute is shared
print(aapl.exchange)   # "NYSE"
print(googl.exchange)  # "NYSE"
Stock.exchange = "NASDAQ"
print(aapl.exchange)   # "NASDAQ" (changed for all!)
~~~

### Methods

~~~python runnable
class BankAccount:
    def __init__(self, balance=0):
        self.balance = balance
        self.transactions = []

    def deposit(self, amount):
        """Add money to account."""
        if amount <= 0:
            raise ValueError("Deposit must be positive")
        self.balance += amount
        self.transactions.append(f"+{amount}")

    def withdraw(self, amount):
        """Remove money from account."""
        if amount <= 0:
            raise ValueError("Withdrawal must be positive")
        if amount > self.balance:
            raise ValueError("Insufficient funds")
        self.balance -= amount
        self.transactions.append(f"-{amount}")

    def get_statement(self):
        """Return transaction history."""
        return "\n".join(self.transactions)


account = BankAccount(1000)
account.deposit(500)
account.withdraw(200)
print(account.balance)        # 1300
print(account.get_statement())
# +500
# -200
~~~

### Special Methods (Dunder Methods)

Python uses double-underscore methods for operator overloading:

~~~python runnable
class Money:
    def __init__(self, amount, currency="USD"):
        self.amount = amount
        self.currency = currency

    def __add__(self, other):
        """Enable: money1 + money2"""
        if self.currency != other.currency:
            raise ValueError("Cannot add different currencies")
        return Money(self.amount + other.amount, self.currency)

    def __sub__(self, other):
        """Enable: money1 - money2"""
        if self.currency != other.currency:
            raise ValueError("Cannot subtract different currencies")
        return Money(self.amount - other.amount, self.currency)

    def __mul__(self, factor):
        """Enable: money * 2"""
        return Money(self.amount * factor, self.currency)

    def __eq__(self, other):
        """Enable: money1 == money2"""
        return self.amount == other.amount and self.currency == other.currency

    def __lt__(self, other):
        """Enable: money1 < money2 (and sorting)"""
        if self.currency != other.currency:
            raise ValueError("Cannot compare different currencies")
        return self.amount < other.amount

    def __str__(self):
        return f"${self.amount:.2f} {self.currency}"


a = Money(100)
b = Money(50)
print(a + b)        # $150.00 USD
print(a - b)        # $50.00 USD
print(a * 3)        # $300.00 USD
print(a == b)       # False
print(a > b)        # True

# Sorting works because __lt__ is defined
prices = [Money(100), Money(50), Money(75)]
print(sorted(prices))  # [$50.00, $75.00, $100.00]
~~~

### Properties

Control access to attributes:

~~~python runnable
class Stock:
    def __init__(self, symbol, shares, price):
        self.symbol = symbol
        self._shares = shares   # Convention: underscore = "private"
        self._price = price

    @property
    def shares(self):
        """Get number of shares."""
        return self._shares

    @shares.setter
    def shares(self, value):
        """Set shares with validation."""
        if value < 0:
            raise ValueError("Shares cannot be negative")
        self._shares = value

    @property
    def price(self):
        return self._price

    @price.setter
    def price(self, value):
        if value <= 0:
            raise ValueError("Price must be positive")
        self._price = value

    @property
    def value(self):
        """Calculated property (no setter = read-only)."""
        return self._shares * self._price


stock = Stock("AAPL", 100, 175)
print(stock.value)    # 17500 (looks like attribute, but calls method)

stock.shares = 200    # Calls the setter
print(stock.shares)   # 200
~~~

Note: The following would raise errors if uncommented:

```python
stock.shares = -10    # ValueError: Shares cannot be negative
stock.value = 5000    # AttributeError: can't set attribute
```

---

## The Exercise

### Exercise 6.1: Stock Class
~~~python exercise id="2.5.1"
class Stock:
    """
    Create a Stock class with:
    - Attributes: symbol, shares, purchase_price, current_price
    - Methods:
        - market_value(): returns shares * current_price
        - gain_loss(): returns market_value - cost_basis
        - gain_loss_percent(): returns percentage gain/loss
        - __str__(): nice string representation
    """
    pass

# Test:
aapl = Stock("AAPL", 100, 150.00, 175.50)
print(aapl)                    # AAPL: 100 shares, cost $150.00, now $175.50
print(aapl.market_value())     # 17550.0
print(aapl.gain_loss())        # 2550.0
print(aapl.gain_loss_percent()) # 17.0
~~~

### Exercise 6.2: Portfolio Class
~~~python exercise id="2.5.2"
class Portfolio:
    """
    Create a Portfolio class with:
    - Attributes: name, holdings (list of Stock objects)
    - Methods:
        - add_stock(stock): add a Stock to holdings
        - remove_stock(symbol): remove stock by symbol
        - total_value(): sum of all stock market values
        - total_gain_loss(): sum of all gains/losses
        - best_performer(): return the Stock with highest % gain
        - __str__(): summary of portfolio
    """
    pass
~~~

### Exercise 6.3: Transaction System
~~~python exercise id="2.5.3"
class Transaction:
    """Represents a buy/sell transaction."""
    pass

class TradingAccount:
    """
    Create a TradingAccount with:
    - cash balance
    - holdings (dict: symbol -> shares)
    - transaction history

    Methods:
    - buy(symbol, shares, price): buy shares, deduct cash
    - sell(symbol, shares, price): sell shares, add cash
    - get_holding(symbol): return number of shares owned
    - get_history(): return list of all transactions
    """
    pass
~~~

---

## The Gotchas

### Gotcha 1: Forgetting self

```python
class Stock:
    def __init__(self, symbol):
        symbol = symbol  # WRONG: assigns to local variable

    def __init__(self, symbol):
        self.symbol = symbol  # RIGHT: assigns to instance
```

### Gotcha 2: Mutable Class Attributes

```python
class Portfolio:
    holdings = []  # WRONG: shared by ALL instances!

    def add(self, stock):
        self.holdings.append(stock)

p1 = Portfolio()
p2 = Portfolio()
p1.add("AAPL")
print(p2.holdings)  # ["AAPL"] - p2 affected!

# RIGHT: initialize in __init__
class Portfolio:
    def __init__(self):
        self.holdings = []  # Each instance gets its own list
```

### Gotcha 3: Calling Methods Without Parentheses

```python
stock = Stock("AAPL", 100, 175)
print(stock.value)    # If property: 17500
print(stock.value())  # If method: 17500

# Without parentheses on a method:
print(stock.market_value)  # <bound method Stock.market_value...>
# (Prints the method object, doesn't call it!)
```

### Gotcha 4: `__str__` vs `__repr__`

```python
# __str__: for end users (print)
# __repr__: for developers (debugging, should be unambiguous)

class Stock:
    def __str__(self):
        return f"{self.symbol}: ${self.price}"  # Pretty

    def __repr__(self):
        return f"Stock('{self.symbol}', {self.shares}, {self.price})"  # Precise

# If only __repr__ is defined, it's used for both
# Always define at least __repr__
```

---

## Key Takeaways

1. Classes bundle data (attributes) and behavior (methods)
2. `__init__` sets up initial state when creating instances
3. `self` refers to the current instance—always the first parameter
4. Use properties to add validation or computed attributes
5. Special methods (`__str__`, `__add__`, etc.) enable Python syntax
6. Instance attributes go in `__init__`, not at class level

---

## Next Lesson

You've built individual classes. Now combine everything into a real application: **Project: Portfolio Tracker**.
