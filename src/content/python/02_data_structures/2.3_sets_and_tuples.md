---
title: "Sets and Tuples"
phase: 2
order: 3
requires: []
prev: "2.2_dictionaries"
next: "2.4_functions"
---

# Lesson 3: Sets and Tuples

## The Problem

Lists and dictionaries cover most needs, but sometimes you need something more specialized:
- **Sets**: When you care about uniqueness and fast membership testing
- **Tuples**: When you need an immutable sequence (can't be changed)

---

## Sets

### The Metaphor

A set is like a **bag of unique items**. You can add marbles, but duplicates fall right out—each color appears only once. You can quickly check "do I have a red marble?" but you can't ask "what's the third marble?" (no order/indexing).

### Creating Sets

~~~python runnable
# From literal
stocks = {"AAPL", "GOOGL", "MSFT"}

# From list (removes duplicates!)
numbers = set([1, 2, 2, 3, 3, 3])  # {1, 2, 3}

# Empty set (NOT {} - that's an empty dict)
empty = set()
~~~

### Set Operations

~~~python runnable
tech = {"AAPL", "GOOGL", "MSFT"}
faang = {"META", "AAPL", "AMZN", "NFLX", "GOOGL"}

# Union (in either)
tech | faang  # {'AAPL', 'AMZN', 'GOOGL', 'META', 'MSFT', 'NFLX'}

# Intersection (in both)
tech & faang  # {'AAPL', 'GOOGL'}

# Difference (in first but not second)
tech - faang  # {'MSFT'}
faang - tech  # {'AMZN', 'META', 'NFLX'}

# Membership (O(1) - very fast!)
"AAPL" in tech  # True
~~~

### Common Uses

~~~python runnable
# Remove duplicates from list
symbols = ["AAPL", "GOOGL", "AAPL", "MSFT", "GOOGL"]
unique = list(set(symbols))  # ['MSFT', 'GOOGL', 'AAPL'] (order not preserved)

# Fast lookup
valid_symbols = set(load_all_symbols())  # Load once
if user_input in valid_symbols:          # O(1) check
    process(user_input)
~~~

---

## Tuples

### The Metaphor

A tuple is like **coordinates on a map**: (latitude, longitude). The order matters, but you can't change just the latitude—you'd get a different location entirely. Tuples are **immutable** snapshots.

### Creating Tuples

~~~python runnable
# Parentheses (optional but recommended)
point = (10, 20)
stock = ("AAPL", 175.50, 100)

# Without parentheses
point = 10, 20

# Single element (comma required!)
single = (42,)    # Tuple
not_tuple = (42)  # Just int 42

# From list
t = tuple([1, 2, 3])
~~~

### Why Use Tuples?

1. **Dictionary keys**: Lists can't be keys, tuples can
   ~~~python runnable
   locations = {
       (40.7128, -74.0060): "New York",
       (51.5074, -0.1278): "London"
   }
   ~~~

2. **Return multiple values**
   ~~~python runnable
   def analyze(prices):
       return min(prices), max(prices), sum(prices)/len(prices)

   low, high, avg = analyze([100, 150, 125])
   ~~~

3. **Prevent accidental modification**
   ~~~python runnable
   VALID_ACTIONS = ("buy", "sell", "hold")  # Can't accidentally add items
   ~~~

### Named Tuples (Better Tuples)

~~~python runnable
from collections import namedtuple

Stock = namedtuple("Stock", ["symbol", "price", "shares"])
aapl = Stock("AAPL", 175.50, 100)

print(aapl.symbol)  # "AAPL" (accessed by name!)
print(aapl[0])      # "AAPL" (still works by index)
print(aapl.price * aapl.shares)  # 17550.0
~~~

---

## Exercise

~~~python exercise id="2.3.1"
# Exercise 2.3.1: Use sets to find:
portfolio1 = {"AAPL", "GOOGL", "MSFT", "AMZN"}
portfolio2 = {"GOOGL", "TSLA", "NVDA", "AMZN"}

# 1. Stocks in both portfolios
# 2. Stocks unique to portfolio1
# 3. All stocks across both portfolios
~~~

~~~python exercise id="2.3.2"
# Exercise 2.3.2: Create a namedtuple for trade records
# Fields: symbol, action, shares, price, timestamp
~~~

---

## Key Takeaways

1. **Sets**: Unordered, unique elements, O(1) membership test
2. **Tuples**: Immutable sequences, can be dict keys, good for records
3. Use `set()` to remove duplicates (but lose order)
4. Use namedtuples for readable data records
5. Sets can't contain mutable items (no lists inside sets)
