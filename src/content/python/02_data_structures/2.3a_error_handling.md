---
title: "Error Handling"
phase: 2
order: 3.5
requires: []
prev: "2.3_sets_and_tuples"
next: "2.4_functions"
---

# Lesson: Error Handling

## The Problem

Programs fail. Networks go down. Files don't exist. Users enter garbage. APIs return errors. If your program crashes every time something unexpected happens, it's useless. You need a way to **anticipate failures** and **handle them gracefully**.

---

## The Metaphor

Error handling is like **defensive driving**:

- You don't assume other drivers will follow the rules
- You anticipate what could go wrong (car runs red light, tire blows out)
- You have a plan for each scenario (brake, steer, pull over)
- You don't panic—you handle the situation calmly

In code, **exceptions** are the unexpected events, and **try/except** is your plan for handling them.

---

## The Technical Reality

### The Exception Hierarchy

Python's exceptions form a hierarchy:

```
BaseException
├── SystemExit
├── KeyboardInterrupt
├── GeneratorExit
└── Exception
    ├── StopIteration
    ├── ArithmeticError
    │   ├── ZeroDivisionError
    │   ├── OverflowError
    │   └── FloatingPointError
    ├── LookupError
    │   ├── IndexError
    │   └── KeyError
    ├── ValueError
    ├── TypeError
    ├── AttributeError
    ├── OSError
    │   ├── FileNotFoundError
    │   ├── PermissionError
    │   └── ConnectionError
    └── ... (many more)
```

You almost always catch `Exception` or its subclasses—never `BaseException` (that includes `KeyboardInterrupt` which should stop your program).

### How Exceptions Work

When an error occurs:
1. Python creates an exception object
2. It "raises" (throws) the exception
3. Python searches up the call stack for a handler
4. If found, the handler runs; if not, the program crashes

~~~python runnable
def divide(a, b):
    return a / b

def calculate():
    return divide(10, 0)  # This will raise ZeroDivisionError

# Without handling, this crashes:
# calculate()

# With handling:
try:
    result = calculate()
    print(f"Result: {result}")
except ZeroDivisionError:
    print("Cannot divide by zero!")
~~~

---

## The Code

### Basic try/except

~~~python runnable
# Catch a specific exception
try:
    result = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero!")

# Catch and access the exception object
try:
    result = 10 / 0
except ZeroDivisionError as e:
    print(f"Error: {e}")  # "division by zero"

# Catch multiple exception types
try:
    # This could raise different errors
    value = int("not a number")
except (ValueError, TypeError) as e:
    print(f"Conversion error: {e}")
~~~

### Multiple except Blocks

~~~python runnable
def get_item(data, index):
    try:
        return data[index]
    except IndexError:
        print(f"Index {index} out of range")
        return None
    except KeyError:
        print(f"Key {index} not found")
        return None
    except TypeError:
        print("Data doesn't support indexing")
        return None

# Test with different types
print(get_item([1, 2, 3], 10))        # Index error
print(get_item({"a": 1}, "b"))        # Key error
print(get_item(42, 0))                # Type error
~~~

### else and finally

~~~python runnable
def safe_divide(a, b):
    try:
        result = a / b
    except ZeroDivisionError:
        print("Cannot divide by zero")
        return None
    else:
        # Runs ONLY if no exception was raised
        print(f"Division successful: {result}")
        return result
    finally:
        # ALWAYS runs, even if exception was raised
        print("Cleanup complete")

print("Test 1:")
safe_divide(10, 2)

print("\nTest 2:")
safe_divide(10, 0)
~~~

The `finally` block is crucial for cleanup—closing files, releasing resources, etc.

### Raising Exceptions

~~~python runnable
def withdraw(balance, amount):
    """Withdraw from balance, raising exception if invalid."""
    if amount < 0:
        raise ValueError("Amount cannot be negative")
    if amount > balance:
        raise ValueError(f"Insufficient funds: {balance} < {amount}")
    return balance - amount

# Using the function
try:
    new_balance = withdraw(100, 150)
except ValueError as e:
    print(f"Withdrawal failed: {e}")

# Negative amount
try:
    new_balance = withdraw(100, -50)
except ValueError as e:
    print(f"Withdrawal failed: {e}")
~~~

### Re-raising Exceptions

~~~python runnable
def process_data(data):
    try:
        result = int(data)
        return result * 2
    except ValueError:
        print(f"Warning: Could not process '{data}'")
        raise  # Re-raise the same exception

# The exception propagates up
try:
    process_data("not a number")
except ValueError as e:
    print(f"Caught at top level: {e}")
~~~

### Custom Exceptions

~~~python runnable
# Define custom exception classes
class TradingError(Exception):
    """Base exception for trading operations."""
    pass

class InsufficientFundsError(TradingError):
    """Raised when account has insufficient funds."""
    def __init__(self, required, available):
        self.required = required
        self.available = available
        super().__init__(f"Need ${required}, but only ${available} available")

class InvalidSymbolError(TradingError):
    """Raised when stock symbol is invalid."""
    pass

class MarketClosedError(TradingError):
    """Raised when trying to trade while market is closed."""
    pass

# Using custom exceptions
def buy_stock(symbol, shares, price, balance):
    if not symbol.isalpha() or len(symbol) > 5:
        raise InvalidSymbolError(f"Invalid symbol: {symbol}")

    total_cost = shares * price
    if total_cost > balance:
        raise InsufficientFundsError(total_cost, balance)

    return balance - total_cost

# Handle custom exceptions
try:
    new_balance = buy_stock("AAPL", 100, 175.50, 10000)
    print(f"New balance: ${new_balance:.2f}")
except InsufficientFundsError as e:
    print(f"Cannot buy: {e}")
    print(f"  Short by: ${e.required - e.available:.2f}")
except InvalidSymbolError as e:
    print(f"Bad symbol: {e}")
except TradingError as e:
    print(f"Trading error: {e}")
~~~

### Exception Chaining

~~~python runnable
def load_config(filename):
    try:
        with open(filename) as f:
            return f.read()
    except FileNotFoundError as e:
        # Raise a new exception, but preserve the original cause
        raise RuntimeError(f"Could not load config from {filename}") from e

try:
    config = load_config("nonexistent.conf")
except RuntimeError as e:
    print(f"Error: {e}")
    print(f"Caused by: {e.__cause__}")
~~~

### Context Managers and Exceptions

~~~python runnable
# Files are automatically closed even if exceptions occur
try:
    with open("test.txt", "w") as f:
        f.write("Hello")
        # If an exception occurs here, file is still closed
        raise ValueError("Something went wrong")
except ValueError:
    print("Caught the error, but file was safely closed")

# Custom context manager for transactions
class Transaction:
    def __init__(self, name):
        self.name = name

    def __enter__(self):
        print(f"Starting transaction: {self.name}")
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is not None:
            print(f"Rolling back {self.name} due to: {exc_val}")
            return False  # Don't suppress the exception
        print(f"Committing {self.name}")
        return True

# Using the context manager
try:
    with Transaction("buy_stock") as txn:
        print("Processing order...")
        raise ValueError("Invalid price")
except ValueError:
    print("Transaction failed")
~~~

---

## The Exercise

### Exercise: API Error Handler
~~~python exercise id="2.3a.1"
def fetch_stock_price(symbol: str) -> float:
    """
    Simulated API call that can fail in various ways.
    """
    import random

    # Simulate various failure modes
    failure = random.choice(["success", "success", "timeout", "not_found", "server_error"])

    if failure == "timeout":
        raise TimeoutError("Connection timed out")
    elif failure == "not_found":
        raise KeyError(f"Symbol {symbol} not found")
    elif failure == "server_error":
        raise RuntimeError("Internal server error")

    return 175.50  # Simulated price

def get_price_with_retry(symbol: str, max_retries: int = 3) -> float | None:
    """
    Fetch stock price with retry logic.

    - Retry on TimeoutError (up to max_retries times)
    - Return None on KeyError (symbol not found)
    - Log RuntimeError and return None
    - Return the price on success
    """
    # YOUR CODE HERE
    pass

# Test it
for _ in range(5):
    price = get_price_with_retry("AAPL")
    print(f"Got price: {price}")
~~~

### Exercise: Safe Dictionary Access
~~~python exercise id="2.3a.2"
def safe_get_nested(data: dict, *keys, default=None):
    """
    Safely navigate nested dictionaries.

    Example:
        data = {"user": {"profile": {"name": "Alice"}}}
        safe_get_nested(data, "user", "profile", "name") -> "Alice"
        safe_get_nested(data, "user", "settings", "theme") -> None
        safe_get_nested(data, "user", "settings", "theme", default="dark") -> "dark"
    """
    # YOUR CODE HERE
    pass

# Test
data = {
    "portfolio": {
        "stocks": {
            "AAPL": {"shares": 100, "price": 175.50},
            "GOOGL": {"shares": 50}
        }
    }
}

print(safe_get_nested(data, "portfolio", "stocks", "AAPL", "shares"))  # 100
print(safe_get_nested(data, "portfolio", "stocks", "AAPL", "dividend"))  # None
print(safe_get_nested(data, "portfolio", "stocks", "MSFT", "shares", default=0))  # 0
print(safe_get_nested(data, "nonexistent", "path"))  # None
~~~

### Exercise: Validation with Exceptions
~~~python exercise id="2.3a.3"
class ValidationError(Exception):
    """Raised when validation fails."""
    def __init__(self, field, message):
        self.field = field
        self.message = message
        super().__init__(f"{field}: {message}")

def validate_trade(trade: dict) -> dict:
    """
    Validate a trade dictionary.

    Required fields:
    - symbol: string, 1-5 uppercase letters
    - action: "BUY" or "SELL"
    - quantity: positive integer
    - price: positive number

    Raises ValidationError for each invalid field.
    Returns the validated trade (with normalized values) if valid.
    """
    errors = []

    # YOUR CODE HERE: validate each field, collect errors

    if errors:
        # Raise the first error (or you could raise all)
        raise errors[0]

    return trade

# Test cases
test_trades = [
    {"symbol": "AAPL", "action": "BUY", "quantity": 100, "price": 175.50},  # Valid
    {"symbol": "aapl", "action": "buy", "quantity": 100, "price": 175.50},  # Should normalize
    {"symbol": "TOOLONG", "action": "BUY", "quantity": 100, "price": 175.50},  # Invalid symbol
    {"symbol": "AAPL", "action": "HOLD", "quantity": 100, "price": 175.50},  # Invalid action
    {"symbol": "AAPL", "action": "BUY", "quantity": -10, "price": 175.50},  # Invalid quantity
]

for trade in test_trades:
    try:
        validated = validate_trade(trade.copy())
        print(f"Valid: {validated}")
    except ValidationError as e:
        print(f"Invalid - {e.field}: {e.message}")
~~~

### Exercise: Resource Manager
~~~python exercise id="2.3a.4"
class DatabaseConnection:
    """
    Simulated database connection with context manager support.

    Implement __enter__ and __exit__ to:
    - Print "Connecting to database..." on enter
    - Print "Disconnecting from database..." on exit
    - If an exception occurred, print "Rolling back due to: {error}"
    - If no exception, print "Committing changes..."
    """

    def __init__(self, db_name: str):
        self.db_name = db_name
        self.connected = False

    def __enter__(self):
        # YOUR CODE HERE
        pass

    def __exit__(self, exc_type, exc_val, exc_tb):
        # YOUR CODE HERE
        # Return False to propagate exceptions, True to suppress
        pass

    def execute(self, query: str):
        if not self.connected:
            raise RuntimeError("Not connected!")
        print(f"Executing: {query}")
        if "ERROR" in query:
            raise RuntimeError("Query failed!")

# Test normal operation
print("=== Normal operation ===")
with DatabaseConnection("stocks.db") as db:
    db.execute("SELECT * FROM prices")
    db.execute("UPDATE prices SET value = 100")

# Test with error
print("\n=== With error ===")
try:
    with DatabaseConnection("stocks.db") as db:
        db.execute("SELECT * FROM prices")
        db.execute("ERROR: bad query")  # This will raise
except RuntimeError as e:
    print(f"Caught: {e}")
~~~

---

## The Gotchas

### Gotcha 1: Catching Too Broadly

~~~python runnable
# BAD - catches everything, including bugs!
try:
    result = some_function()  # NameError: some_function not defined
except:
    pass  # Silently ignores ALL errors, even programming mistakes

# BAD - catches too much
try:
    result = 10 / 0
except Exception:  # Catches ValueError, TypeError, etc. too
    print("Something went wrong")

# GOOD - catch specific exceptions
try:
    result = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero")
~~~

### Gotcha 2: Swallowing Exceptions

~~~python runnable
# BAD - error is lost
def bad_function():
    try:
        return risky_operation()
    except Exception:
        pass  # Error disappears!
    return None

# GOOD - at least log it
import traceback

def better_function():
    try:
        return risky_operation()
    except Exception as e:
        print(f"Error: {e}")
        traceback.print_exc()  # Print full traceback
        return None
~~~

### Gotcha 3: Exception in Exception Handler

~~~python runnable
# If your except block can also raise an exception, use nested try
try:
    result = 10 / 0
except ZeroDivisionError:
    # What if logging fails?
    try:
        log_error("Division by zero")  # NameError!
    except Exception:
        pass  # At least don't crash
    result = 0
~~~

### Gotcha 4: finally Always Runs (Even with return)

~~~python runnable
def example():
    try:
        return "from try"
    finally:
        print("finally runs!")
        # If you return here, it overrides the try's return!
        # return "from finally"  # Would return this instead

result = example()
print(f"Got: {result}")

# Be careful: finally can suppress exceptions if it returns
def dangerous():
    try:
        raise ValueError("Error!")
    finally:
        return "finally"  # Suppresses the exception!

print(dangerous())  # "finally" - no exception raised!
~~~

### Gotcha 5: Exceptions in __del__

~~~python runnable
class Resource:
    def __del__(self):
        # Exceptions in __del__ are ignored and just print a warning
        raise ValueError("Cleanup failed!")

r = Resource()
del r  # Just prints warning, doesn't raise
print("Program continues...")

# Use context managers instead of __del__ for cleanup
~~~

---

## Real World Application: Robust API Client

~~~python runnable
import time

class APIError(Exception):
    """Base class for API errors."""
    pass

class RateLimitError(APIError):
    """Too many requests."""
    def __init__(self, retry_after=60):
        self.retry_after = retry_after
        super().__init__(f"Rate limited. Retry after {retry_after}s")

class AuthenticationError(APIError):
    """Invalid credentials."""
    pass

class StockAPIClient:
    """
    Robust API client with error handling.
    """

    def __init__(self, api_key):
        self.api_key = api_key
        self.request_count = 0

    def _make_request(self, endpoint):
        """Simulate API request with various failure modes."""
        self.request_count += 1

        # Simulate rate limiting
        if self.request_count % 5 == 0:
            raise RateLimitError(retry_after=2)

        # Simulate occasional failures
        if self.request_count % 7 == 0:
            raise ConnectionError("Network error")

        return {"price": 175.50, "symbol": endpoint}

    def get_price(self, symbol, max_retries=3):
        """
        Get stock price with automatic retry on transient failures.
        """
        last_error = None

        for attempt in range(max_retries):
            try:
                response = self._make_request(symbol)
                return response["price"]

            except RateLimitError as e:
                print(f"Rate limited, waiting {e.retry_after}s...")
                time.sleep(0.1)  # Simulated wait (shorter for demo)
                last_error = e

            except ConnectionError as e:
                print(f"Connection error (attempt {attempt + 1}): {e}")
                last_error = e
                time.sleep(0.1)  # Back off before retry

            except AuthenticationError:
                # Don't retry auth errors
                raise

        raise last_error  # All retries failed

# Demo
client = StockAPIClient("my-api-key")
for i in range(10):
    try:
        price = client.get_price("AAPL")
        print(f"Request {i+1}: ${price}")
    except APIError as e:
        print(f"Request {i+1} failed: {e}")
~~~

---

## Key Takeaways

1. Use `try/except` to handle expected errors gracefully
2. Catch **specific** exceptions—never bare `except:`
3. Use `finally` for cleanup that must always happen
4. Use `else` for code that should only run if no exception occurred
5. Create **custom exceptions** for domain-specific errors
6. Use `raise` to signal errors; `raise ... from ...` to chain them
7. Context managers (`with`) ensure cleanup even when exceptions occur
8. Log errors before handling—don't swallow them silently

---

## Next Lesson

Now that you can handle errors gracefully, let's organize code into reusable pieces: **Functions**.
