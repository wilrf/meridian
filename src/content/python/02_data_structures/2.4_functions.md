---
title: "Functions"
phase: 2
order: 4
requires: []
prev: "2.3_sets_and_tuples"
next: "2.5_classes"
---

# Lesson 4: Functions

## The Problem

You've written code to calculate portfolio returns. Now you need the same calculation in three different places. Do you copy-paste? That leads to bugs—fix one copy, forget the others. You need a way to write code once and use it many times.

---

## The Metaphor

A function is like a **recipe**:

- It has a **name** ("Chocolate Cake")
- It takes **ingredients** (parameters): flour, sugar, eggs
- It **produces something** (return value): a cake
- The same recipe can be used to make many cakes with different ingredients

You don't rewrite the recipe every time you bake. You define it once, then call it whenever needed.

---

## The Technical Reality

### Functions Are Objects

In Python, functions are **first-class objects**—they can be:
- Assigned to variables
- Passed as arguments
- Returned from other functions
- Stored in lists/dicts

~~~python runnable
def greet(name):
    return f"Hello, {name}"

# Function is an object
print(type(greet))  # <class 'function'>

# Assign to variable
say_hello = greet
say_hello("World")  # "Hello, World"

# Pass as argument
def apply_twice(func, x):
    return func(func(x))

def double(n):
    return n * 2

apply_twice(double, 3)  # 12 (double(double(3)))
~~~

### Call Stack

When you call a function, Python creates a **stack frame**:

~~~python runnable
def outer():
    x = 1
    inner()    # New frame pushed
    print(x)   # Frame popped, back to outer

def inner():
    y = 2
    # inner's variables exist only here
~~~

```
Call Stack:
│ inner() │  ← Currently executing
├─────────┤
│ outer() │
├─────────┤
│ main    │
└─────────┘
```

When `inner()` returns, its frame is destroyed and execution resumes in `outer()`.

---

## The Code

### Defining Functions

~~~python runnable
# Basic function
def greet():
    print("Hello!")

# With parameters
def greet(name):
    print(f"Hello, {name}!")

# With return value
def add(a, b):
    return a + b

result = add(3, 5)  # 8

# Multiple return values (returns a tuple)
def analyze_price(price, prev_price):
    change = price - prev_price
    percent = (change / prev_price) * 100
    direction = "up" if change > 0 else "down" if change < 0 else "flat"
    return change, percent, direction

change, pct, dir = analyze_price(175, 170)

# Early return
def get_grade(score):
    if score >= 90:
        return "A"
    if score >= 80:
        return "B"
    if score >= 70:
        return "C"
    return "F"
~~~

### Parameters and Arguments

~~~python runnable
# Positional arguments
def calculate_value(shares, price):
    return shares * price

calculate_value(100, 175.50)  # shares=100, price=175.50

# Keyword arguments
calculate_value(price=175.50, shares=100)  # Same result, explicit names

# Default values
def calculate_value(shares, price, currency="USD"):
    return f"{shares * price} {currency}"

calculate_value(100, 175)         # "17500 USD"
calculate_value(100, 175, "EUR")  # "17500 EUR"

# Required vs optional
def place_order(symbol, shares, order_type="market", limit_price=None):
    """
    symbol, shares: required
    order_type: optional, defaults to "market"
    limit_price: optional, defaults to None
    """
    pass

place_order("AAPL", 100)
place_order("AAPL", 100, "limit", 170.00)
place_order("AAPL", 100, limit_price=170.00, order_type="limit")
~~~

### *args and **kwargs

~~~python runnable
# *args: variable positional arguments (tuple)
def sum_all(*numbers):
    total = 0
    for n in numbers:
        total += n
    return total

sum_all(1, 2, 3)           # 6
sum_all(1, 2, 3, 4, 5)     # 15

# **kwargs: variable keyword arguments (dict)
def create_stock(**attributes):
    return attributes

stock = create_stock(symbol="AAPL", price=175, shares=100)
# {"symbol": "AAPL", "price": 175, "shares": 100}

# Combining all parameter types
def flexible(required, *args, default="value", **kwargs):
    print(f"required: {required}")
    print(f"args: {args}")
    print(f"default: {default}")
    print(f"kwargs: {kwargs}")

flexible("must have", 1, 2, 3, default="custom", extra="data")
# required: must have
# args: (1, 2, 3)
# default: custom
# kwargs: {"extra": "data"}
~~~

### Docstrings

~~~python runnable
def calculate_returns(prices):
    """
    Calculate daily returns from a list of prices.

    Parameters
    ----------
    prices : list of float
        Daily closing prices. Must have at least 2 values.

    Returns
    -------
    list of float
        Daily percentage returns. Length is len(prices) - 1.

    Examples
    --------
    >>> calculate_returns([100, 110, 105])
    [0.1, -0.0455]

    Raises
    ------
    ValueError
        If prices has fewer than 2 elements.
    """
    if len(prices) < 2:
        raise ValueError("Need at least 2 prices")

    returns = []
    for i in range(1, len(prices)):
        daily_return = (prices[i] - prices[i-1]) / prices[i-1]
        returns.append(daily_return)
    return returns

# Access docstring
print(calculate_returns.__doc__)
help(calculate_returns)
~~~

### Lambda Functions

Anonymous functions for simple, one-time use:

~~~python runnable
# Regular function
def double(x):
    return x * 2

# Lambda equivalent
double = lambda x: x * 2

# Common use: sorting
stocks = [("AAPL", 175), ("GOOGL", 140), ("MSFT", 380)]

# Sort by price
sorted(stocks, key=lambda x: x[1])
# [("GOOGL", 140), ("AAPL", 175), ("MSFT", 380)]

# Common use: filtering
prices = [100, -5, 200, 0, 150]
valid = list(filter(lambda p: p > 0, prices))
# [100, 200, 150]

# Common use: mapping
prices = [100, 150, 200]
doubled = list(map(lambda p: p * 2, prices))
# [200, 300, 400]
~~~

### Type Hints (Python 3.5+)

~~~python runnable
def calculate_returns(prices: list[float]) -> list[float]:
    """Calculate daily returns from prices."""
    returns: list[float] = []
    for i in range(1, len(prices)):
        daily_return: float = (prices[i] - prices[i-1]) / prices[i-1]
        returns.append(daily_return)
    return returns

# More complex type hints
from typing import Optional, Union

def get_price(symbol: str, default: Optional[float] = None) -> Optional[float]:
    """Return price or default if not found."""
    prices = {"AAPL": 175.50}
    return prices.get(symbol, default)

def process(value: Union[int, float]) -> float:
    """Accept int or float, return float."""
    return float(value)
~~~

Type hints don't enforce anything at runtime—they're documentation and enable tooling (IDE autocomplete, static analyzers like mypy).

---

## The Exercise

### Exercise 4.1: Basic Functions
~~~python exercise id="2.4.1"
# Write these functions:

def celsius_to_fahrenheit(celsius):
    """Convert Celsius to Fahrenheit."""
    pass

def calculate_compound_interest(principal, rate, years):
    """
    Calculate compound interest.
    Formula: A = P(1 + r)^t
    Return the final amount.
    """
    pass

def is_valid_ticker(symbol):
    """
    Return True if symbol is valid:
    - 1-5 uppercase letters
    - No numbers or special characters
    """
    pass
~~~

### Exercise 4.2: Statistical Functions
~~~python exercise id="2.4.2"
def mean(numbers):
    """Calculate arithmetic mean."""
    pass

def variance(numbers):
    """Calculate population variance."""
    # Hint: variance = sum((x - mean)^2) / n
    pass

def std_dev(numbers):
    """Calculate standard deviation."""
    pass

# Test with:
data = [100, 102, 98, 105, 97, 103, 99, 101]
~~~

### Exercise 4.3: Higher-Order Functions
~~~python exercise id="2.4.3"
# A higher-order function takes or returns a function

def apply_to_all(func, items):
    """Apply func to each item, return list of results."""
    pass

def create_multiplier(factor):
    """Return a function that multiplies by factor."""
    pass

# Usage:
double = create_multiplier(2)
triple = create_multiplier(3)
print(double(5))  # 10
print(triple(5))  # 15
~~~

### Exercise 4.4: Portfolio Analyzer
~~~python exercise id="2.4.4"
def analyze_portfolio(holdings: list[dict]) -> dict:
    """
    Analyze a portfolio of holdings.

    Parameters
    ----------
    holdings : list of dict
        Each dict has: symbol, shares, purchase_price, current_price

    Returns
    -------
    dict with:
        - total_value: sum of current values
        - total_cost: sum of purchase costs
        - total_gain: total_value - total_cost
        - best_performer: symbol with highest % gain
        - worst_performer: symbol with lowest % gain
    """
    pass

# Test with:
portfolio = [
    {"symbol": "AAPL", "shares": 10, "purchase_price": 150, "current_price": 175},
    {"symbol": "GOOGL", "shares": 5, "purchase_price": 130, "current_price": 140},
    {"symbol": "MSFT", "shares": 8, "purchase_price": 300, "current_price": 280},
]
~~~

---

## The Gotchas

### Gotcha 1: Mutable Default Arguments

```python
# DANGEROUS - the list is shared across all calls!
def add_item(item, items=[]):
    items.append(item)
    return items

print(add_item("a"))  # ["a"]
print(add_item("b"))  # ["a", "b"] - What?!

# SAFE - use None and create inside
def add_item(item, items=None):
    if items is None:
        items = []
    items.append(item)
    return items
```

### Gotcha 2: Return None Implicitly

```python
def process(x):
    if x > 0:
        return x * 2
    # If x <= 0, implicitly returns None!

result = process(-5)
print(result)  # None

# Always handle all paths explicitly
def process(x):
    if x > 0:
        return x * 2
    return 0  # Or raise an exception
```

### Gotcha 3: Modifying Arguments

```python
def bad_double(numbers):
    for i in range(len(numbers)):
        numbers[i] *= 2  # Modifies the original list!

original = [1, 2, 3]
bad_double(original)
print(original)  # [2, 4, 6] - original changed!

# Better: return a new list
def good_double(numbers):
    return [n * 2 for n in numbers]
```

### Gotcha 4: Keyword Arguments Must Follow Positional

```python
def func(a, b, c):
    pass

# WRONG
func(a=1, 2, 3)  # SyntaxError: positional after keyword

# RIGHT
func(1, b=2, c=3)
func(1, 2, c=3)
func(a=1, b=2, c=3)
```

---

## Key Takeaways

1. Functions encapsulate reusable code
2. Use docstrings to document parameters, returns, and examples
3. Functions are first-class objects—pass them around freely
4. `*args` for variable positional, `**kwargs` for variable keyword
5. Never use mutable default arguments—use `None` instead
6. Type hints document expectations (but don't enforce)
7. Lambda for simple, one-off functions

---

## Next Lesson

Functions create their own local world of variables. But how does Python decide which `x` you mean when you have multiple? Next: **Scope and Namespaces**.
