---
title: "Lists"
phase: 2
order: 1
requires: []
prev: "1.6_loops"
next: "2.2_dictionaries"
---

# Lesson 1: Lists

## The Problem

You've stored individual values in variables. But what if you have 1,000 stock prices? You can't create `price1`, `price2`, ... `price1000`. You need a single container that holds multiple values and lets you work with them as a group.

---

## The Metaphor

A list is like a **train with numbered cars**:

- Each car (element) holds one item
- Cars are numbered in order (0, 1, 2, ...)
- You can add cars to the end, remove cars, or rearrange them
- The train itself is one unit, but you can access individual cars by number

Unlike a real train, you can also insert cars in the middle, and the train automatically renumbers everything.

---

## The Technical Reality

### Lists Are Arrays of References

A Python list doesn't store values directly—it stores **references** (pointers) to objects:

```
my_list = [100, "AAPL", 3.14]

my_list (the list object)
┌───────────────────────────┐
│ [ref0] [ref1] [ref2]      │
└───┬───────┬───────┬───────┘
    │       │       │
    ▼       ▼       ▼
  [100]  ["AAPL"] [3.14]
```

This is why:
- Lists can hold mixed types (each slot just holds a reference)
- Appending is fast (just add a new reference)
- Looking up by index is O(1) (constant time)
- Inserting in the middle is O(n) (must shift all references after)

### Mutability

Lists are **mutable**—you can change them after creation:

~~~python runnable
prices = [100, 200, 300]
prices[0] = 999  # Modify in place
print(prices)    # [999, 200, 300]
~~~

This is powerful but dangerous when combined with references:

~~~python runnable
original = [1, 2, 3]
alias = original       # Both point to SAME list
alias.append(4)
print(original)        # [1, 2, 3, 4] - original changed!

copy = original[:]     # Creates a NEW list
copy.append(5)
print(original)        # [1, 2, 3, 4] - unchanged
~~~

---

## The Code

### Creating Lists

~~~python runnable
# Empty list
empty = []
also_empty = list()

# List with initial values
prices = [100, 150, 125]
mixed = [1, "two", 3.0, True, None]

# List from other iterables
chars = list("AAPL")           # ['A', 'A', 'P', 'L']
numbers = list(range(5))       # [0, 1, 2, 3, 4]

# List multiplication (repeating)
zeros = [0] * 10               # [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
grid = [[0] * 3 for _ in range(3)]  # 3x3 grid (correct way)

print(chars)
print(numbers)
print(zeros)
~~~

### Indexing and Slicing

~~~python runnable
stocks = ["AAPL", "GOOGL", "MSFT", "AMZN", "TSLA"]

# Positive indexing (from start)
print(stocks[0])    # "AAPL" (first)
print(stocks[1])    # "GOOGL" (second)
print(stocks[4])    # "TSLA" (fifth/last)

# Negative indexing (from end)
print(stocks[-1])   # "TSLA" (last)
print(stocks[-2])   # "AMZN" (second to last)

# Slicing [start:stop:step] - stop is exclusive!
print(stocks[1:3])    # ["GOOGL", "MSFT"] (index 1 and 2)
print(stocks[:3])     # ["AAPL", "GOOGL", "MSFT"] (first 3)
print(stocks[2:])     # ["MSFT", "AMZN", "TSLA"] (from index 2 to end)
print(stocks[::2])    # ["AAPL", "MSFT", "TSLA"] (every 2nd)
print(stocks[::-1])   # ["TSLA", "AMZN", "MSFT", "GOOGL", "AAPL"] (reversed)

# Slicing creates a NEW list
subset = stocks[1:3]
subset[0] = "META"
print(stocks)  # Original unchanged: ["AAPL", "GOOGL", ...]
~~~

### Modifying Lists

~~~python runnable
prices = [100, 150, 125]

# Change element
prices[1] = 160
print(prices)

# Append (add to end) - O(1)
prices.append(175)        # [100, 160, 125, 175]
print(prices)

# Extend (add multiple to end)
prices.extend([180, 185]) # [100, 160, 125, 175, 180, 185]
# Or: prices += [180, 185]
print(prices)

# Insert at position - O(n)
prices.insert(0, 95)      # [95, 100, 160, ...] - slow for large lists
print(prices)

# Remove by value (first occurrence)
prices.remove(160)        # Removes first 160
print(prices)

# Remove by index
del prices[0]             # Delete first element
popped = prices.pop()     # Remove and return last element
print(f"Popped: {popped}, List: {prices}")
popped = prices.pop(0)    # Remove and return first element
print(f"Popped: {popped}, List: {prices}")

# Clear all
prices.clear()            # []
print(prices)
~~~

### List Operations

~~~python runnable
a = [1, 2, 3]
b = [4, 5, 6]

# Concatenation (creates new list)
c = a + b         # [1, 2, 3, 4, 5, 6]
print(c)

# Membership test
print(2 in a)     # True
print(7 in a)     # False

# Length, min, max, sum
print(len(a))     # 3
print(min(a))     # 1
print(max(a))     # 3
print(sum(a))     # 6

# Count occurrences
print([1, 2, 2, 3, 2].count(2))  # 3

# Find index (raises ValueError if not found)
print(["A", "B", "C"].index("B"))  # 1

# Sorting
prices = [150, 100, 125]
prices.sort()              # In-place: [100, 125, 150]
print(prices)
prices.sort(reverse=True)  # In-place: [150, 125, 100]
print(prices)

# sorted() returns NEW list, original unchanged
original = [150, 100, 125]
new = sorted(original)     # new: [100, 125, 150], original unchanged
print(f"Original: {original}, New: {new}")

# Reverse
prices.reverse()           # In-place reversal
reversed_prices = prices[::-1]  # New reversed list
print(reversed_prices)
~~~

### List Comprehensions

The Pythonic way to create lists:

~~~python runnable
# Square numbers
squares = [x**2 for x in range(10)]
print(squares)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# With condition
evens = [x for x in range(10) if x % 2 == 0]
print(evens)  # [0, 2, 4, 6, 8]

# Transform existing list
prices = [100, 150, 200]
discounted = [p * 0.9 for p in prices]
print(discounted)  # [90.0, 135.0, 180.0]

# Nested (use sparingly - can get hard to read)
matrix = [[i*j for j in range(3)] for i in range(3)]
print(matrix)  # [[0, 0, 0], [0, 1, 2], [0, 2, 4]]
~~~

---

## The Exercise

### Exercise 2.1: Portfolio Value
~~~python exercise id="2.1"
holdings = [
    ("AAPL", 10, 175.50),   # (symbol, shares, price)
    ("GOOGL", 5, 140.25),
    ("MSFT", 8, 380.00),
]

# Calculate:
# 1. Total portfolio value
# 2. Value of each position (as a new list)
# 3. The largest single position
~~~

### Exercise 2.2: Price Analysis
~~~python exercise id="2.2"
prices = [152, 148, 155, 160, 158, 162, 157, 165, 170, 168]

# Using only list operations and loops:
# 1. Calculate the daily returns (% change from previous day)
# 2. Find all days where price increased by more than 3%
# 3. Find the index of the highest price
~~~

### Exercise 2.3: List Comprehension Practice
Convert these loops to list comprehensions:

~~~python exercise id="2.3"
# Loop 1
result = []
for i in range(1, 11):
    result.append(i ** 3)

# Loop 2
result = []
for word in ["Apple", "Google", "Microsoft"]:
    result.append(word.upper())

# Loop 3
result = []
for n in range(100):
    if n % 3 == 0 and n % 5 == 0:
        result.append(n)
~~~

### Exercise 2.4: Sliding Window Average
~~~python exercise id="2.4"
prices = [100, 102, 101, 105, 110, 108, 112, 115, 113, 118]

# Calculate 3-day moving averages
# Output should be: [101.0, 102.67, 105.33, 107.67, 110.0, 111.67, 113.33, 115.33]
# (First average is mean of prices[0:3], second is mean of prices[1:4], etc.)
~~~

---

## The Gotchas

### Gotcha 1: Shallow Copy vs Deep Copy

```python
# Shallow copy (slicing or copy())
original = [[1, 2], [3, 4]]
shallow = original[:]
shallow[0][0] = 999
print(original)  # [[999, 2], [3, 4]] - inner lists are shared!

# Deep copy
import copy
deep = copy.deepcopy(original)
deep[0][0] = 1
print(original)  # [[999, 2], [3, 4]] - unchanged
```

### Gotcha 2: List Multiplication Creates Shared References

```python
# WRONG - all rows point to same list!
grid = [[0] * 3] * 3
grid[0][0] = 1
print(grid)  # [[1, 0, 0], [1, 0, 0], [1, 0, 0]] - all changed!

# RIGHT - comprehension creates independent lists
grid = [[0] * 3 for _ in range(3)]
grid[0][0] = 1
print(grid)  # [[1, 0, 0], [0, 0, 0], [0, 0, 0]]
```

### Gotcha 3: Index Out of Range

```python
prices = [100, 200, 300]
prices[5]  # IndexError: list index out of range

# Slicing doesn't raise errors
prices[5:10]  # [] (empty list)
```

### Gotcha 4: Sorting Returns None

```python
prices = [150, 100, 125]
result = prices.sort()  # Returns None!
print(result)  # None (sort modifies in place)

# Use sorted() if you need the result
result = sorted(prices)  # Returns new sorted list
```

### Gotcha 5: remove() vs del vs pop()

```python
items = [1, 2, 3, 2, 4]

items.remove(2)  # Removes FIRST occurrence of value 2
# [1, 3, 2, 4]

del items[1]     # Removes by INDEX (doesn't return it)
# [1, 2, 4]

x = items.pop(0) # Removes by INDEX and RETURNS it
# x = 1, items = [2, 4]
```

---

## Key Takeaways

1. Lists are ordered, mutable sequences that hold references to objects
2. Indexing is 0-based; negative indices count from the end
3. Slicing creates a new list (shallow copy)
4. `sort()` modifies in place; `sorted()` returns a new list
5. List comprehensions are the Pythonic way to transform lists
6. Be careful with shared references in nested lists

---

## Next Lesson

Lists are great for ordered sequences, but sometimes you need to look things up by name, not position. Next up: **Dictionaries**.
