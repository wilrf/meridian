---
title: "Dictionaries"
phase: 2
order: 2
requires: []
prev: "2.1_lists"
next: "2.3_sets_and_tuples"
---

# Lesson 2: Dictionaries

## The Problem

Lists access elements by position: `prices[0]`, `prices[1]`. But what if you want to access data by name? "What's AAPL's price?" is more natural than "What's the price at index 3?" You need a data structure that maps **keys** to **values**.

---

## The Metaphor

A dictionary is like a **real dictionary** (the book):

- You look up a **word** (key) to find its **definition** (value)
- Words are unique—no two entries for "apple"
- Words aren't in numerical order—you find them by name, not position
- Looking up a word is fast, even in a thick dictionary

Or think of it like a filing cabinet with labeled folders. You don't say "give me folder #47"—you say "give me the AAPL folder."

---

## The Technical Reality

### Hash Tables Under the Hood

Dictionaries use a **hash table**. When you store `{"AAPL": 175}`:

1. Python computes `hash("AAPL")` → some number like `8744672936293`
2. That hash determines which "slot" in memory stores the value
3. Looking up `prices["AAPL"]` computes the same hash and goes directly to that slot

This is why:
- Lookups are O(1)—constant time regardless of dictionary size
- Keys must be **hashable** (immutable types: strings, numbers, tuples)
- Lists can't be keys (they're mutable, so their hash could change)

~~~python runnable
# Keys must be hashable
valid = {
    "string": 1,       # String - OK
    42: "number",      # Number - OK
    (1, 2): "tuple",   # Tuple - OK
}
print(valid)

# This would cause an error:
# invalid = {
#     [1, 2]: "list"     # TypeError: unhashable type: 'list'
# }
~~~

### Dictionaries Maintain Insertion Order (Python 3.7+)

Modern Python preserves the order you added keys:

~~~python runnable
d = {}
d["c"] = 3
d["a"] = 1
d["b"] = 2

for key in d:
    print(key)  # c, a, b (insertion order)
~~~

---

## The Code

### Creating Dictionaries

~~~python runnable
# Empty dictionary
empty = {}
also_empty = dict()

# Dictionary literal
stock = {
    "symbol": "AAPL",
    "price": 175.50,
    "shares": 100,
    "sector": "technology"
}
print("Stock:", stock)

# From list of tuples
pairs = [("a", 1), ("b", 2), ("c", 3)]
d = dict(pairs)  # {"a": 1, "b": 2, "c": 3}
print("From pairs:", d)

# From keyword arguments
d = dict(name="Apple", price=175)  # {"name": "Apple", "price": 175}
print("From kwargs:", d)

# Dict comprehension
squares = {x: x**2 for x in range(5)}
print("Squares:", squares)
# {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
~~~

### Accessing Values

~~~python runnable
stock = {"symbol": "AAPL", "price": 175.50, "shares": 100}

# Direct access (raises KeyError if missing)
print(stock["symbol"])        # "AAPL"
# stock["dividend"]           # KeyError: 'dividend'

# Safe access with get() (returns None or default if missing)
print(stock.get("dividend"))          # None
print(stock.get("dividend", 0))       # 0 (custom default)
print(stock.get("price"))             # 175.50

# Check if key exists
print("symbol" in stock)              # True
print("dividend" in stock)            # False
print("dividend" not in stock)        # True
~~~

### Modifying Dictionaries

~~~python runnable
stock = {"symbol": "AAPL", "price": 175.50}

# Add or update
stock["shares"] = 100         # Add new key
stock["price"] = 180.00       # Update existing key
print("After add/update:", stock)

# Update with another dictionary
stock.update({"sector": "tech", "price": 182.00})
print("After update:", stock)
# {"symbol": "AAPL", "price": 182.00, "shares": 100, "sector": "tech"}

# Merge (Python 3.9+)
defaults = {"currency": "USD", "exchange": "NASDAQ"}
merged = defaults | stock     # stock values override defaults
print("Merged:", merged)
# or: merged = {**defaults, **stock}  # works in older Python

# Remove
del stock["sector"]           # Remove key (KeyError if missing)
price = stock.pop("price")    # Remove and return value
print("Popped price:", price)

# setdefault: get or set if missing
stock.setdefault("dividend", 0)  # Returns 0, adds "dividend": 0
stock.setdefault("symbol", "???")  # Returns "AAPL", doesn't change
print("Final stock:", stock)
~~~

### Iterating

~~~python runnable
stock = {"symbol": "AAPL", "price": 175.50, "shares": 100}

# Iterate over keys (default)
print("Keys:")
for key in stock:
    print(key)  # symbol, price, shares

# Iterate over values
print("\nValues:")
for value in stock.values():
    print(value)  # AAPL, 175.50, 100

# Iterate over key-value pairs
print("\nKey-value pairs:")
for key, value in stock.items():
    print(f"{key}: {value}")
~~~

### Common Operations

~~~python runnable
stock = {"symbol": "AAPL", "price": 175.50, "shares": 100}

print(len(stock))              # 3 (number of keys)
print(list(stock.keys()))      # ["symbol", "price", "shares"]
print(list(stock.values()))    # ["AAPL", 175.50, 100]
print(list(stock.items()))     # [("symbol", "AAPL"), ("price", 175.50), ...]

copy = stock.copy()     # Shallow copy
print("Copy:", copy)
stock.clear()           # Remove all items
print("After clear:", stock)
~~~

### Nested Dictionaries

~~~python runnable
portfolio = {
    "AAPL": {
        "shares": 100,
        "avg_cost": 150.00,
        "current_price": 175.50
    },
    "GOOGL": {
        "shares": 50,
        "avg_cost": 120.00,
        "current_price": 140.25
    }
}

# Access nested values
print(portfolio["AAPL"]["shares"])         # 100
print(portfolio["AAPL"]["current_price"])  # 175.50

# Calculate position values
for symbol, data in portfolio.items():
    value = data["shares"] * data["current_price"]
    gain = data["shares"] * (data["current_price"] - data["avg_cost"])
    print(f"{symbol}: ${value:.2f} (gain: ${gain:.2f})")
~~~

---

## The Exercise

### Exercise 2.2.1: Stock Lookup
~~~python exercise id="2.2.1"
# Create a dictionary of stock prices
prices = {
    "AAPL": 175.50,
    "GOOGL": 140.25,
    "MSFT": 380.00,
    "AMZN": 178.50,
    "TSLA": 248.00
}

# 1. Look up AAPL's price

# 2. Try to look up "META" safely (should return "Unknown")

# 3. Add META with price 505.00

# 4. Calculate the average price of all stocks

# 5. Find the most expensive stock (symbol and price)

~~~

### Exercise 2.2.2: Word Counter
~~~python exercise id="2.2.2"
text = """
Python is a programming language. Python is used for web development.
Python is also used for data science. Python has simple syntax.
"""

# Create a dictionary counting word frequency
# Output: {"python": 4, "is": 4, "a": 1, ...}

# Hints:
# - text.lower() to normalize case
# - text.split() to get words
# - Remove punctuation or use word.strip(".,!?")

~~~

### Exercise 2.2.3: Grouping Data
~~~python exercise id="2.2.3"
transactions = [
    {"type": "buy", "symbol": "AAPL", "shares": 10},
    {"type": "sell", "symbol": "GOOGL", "shares": 5},
    {"type": "buy", "symbol": "AAPL", "shares": 15},
    {"type": "buy", "symbol": "MSFT", "shares": 20},
    {"type": "sell", "symbol": "AAPL", "shares": 8},
]

# Group transactions by symbol:
# {
#     "AAPL": [{"type": "buy", ...}, {"type": "buy", ...}, {"type": "sell", ...}],
#     "GOOGL": [...],
#     ...
# }

# Then calculate net shares for each symbol

~~~

### Exercise 2.2.4: Inverting a Dictionary
~~~python exercise id="2.2.4"
sector_map = {
    "AAPL": "technology",
    "GOOGL": "technology",
    "JPM": "finance",
    "BAC": "finance",
    "XOM": "energy",
}

# Invert to get stocks by sector:
# {
#     "technology": ["AAPL", "GOOGL"],
#     "finance": ["JPM", "BAC"],
#     "energy": ["XOM"]
# }

~~~

---

## The Gotchas

### Gotcha 1: KeyError vs Silent None

```python
d = {"a": 1}

# Raises exception
d["b"]              # KeyError: 'b'

# Returns None (can hide bugs!)
d.get("b")          # None

# Explicit is better
if "b" in d:
    value = d["b"]
else:
    value = default

# Or use get with meaningful default
value = d.get("b", 0)
```

### Gotcha 2: Modifying While Iterating

```python
d = {"a": 1, "b": 2, "c": 3}

# WRONG - RuntimeError
for key in d:
    if d[key] < 2:
        del d[key]

# RIGHT - iterate over a copy of keys
for key in list(d.keys()):
    if d[key] < 2:
        del d[key]

# BETTER - comprehension
d = {k: v for k, v in d.items() if v >= 2}
```

### Gotcha 3: Mutable Default Values (Again)

```python
# WRONG - all entries share the same list!
def add_to_group(groups, key, value):
    groups.setdefault(key, []).append(value)  # This is actually fine

# But this is wrong:
def make_default_dict():
    return {"items": []}  # New dict each time - OK

# Watch out for class attributes:
class Portfolio:
    holdings = {}  # WRONG - shared across all instances!

class Portfolio:
    def __init__(self):
        self.holdings = {}  # RIGHT - per instance
```

### Gotcha 4: Dictionary Keys Are Unique

```python
d = {"a": 1, "a": 2}
print(d)  # {"a": 2} - second value wins, no error!
```

### Gotcha 5: None vs Missing

```python
d = {"value": None}

# Both return None!
d.get("value")     # None (key exists, value is None)
d.get("missing")   # None (key doesn't exist)

# To distinguish:
if "value" in d:
    print("Key exists, value is:", d["value"])
```

---

## Key Takeaways

1. Dictionaries map keys to values with O(1) lookup
2. Keys must be hashable (strings, numbers, tuples)
3. Use `get()` for safe access with defaults
4. Iteration order is preserved (Python 3.7+)
5. Dict comprehensions: `{k: v for k, v in items}`
6. Never modify a dict while iterating—copy keys first

---

## Next Lesson

You've learned lists (ordered) and dictionaries (keyed). Next: **Sets and Tuples**—two more specialized containers that solve specific problems.
