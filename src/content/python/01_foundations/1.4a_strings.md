---
title: "Strings Deep Dive"
phase: 1
order: 4.5
requires: []
prev: "1.4_operators"
next: "1.5_control_flow"
---

# Lesson 4a: Strings Deep Dive

## The Problem

Text is everywhere in programming: user names, file paths, API responses, error messages, stock symbols. You need to search within text, split it apart, clean it up, and build new strings from pieces. Basic string creation isn't enoughâ€”you need to *manipulate* text.

---

## The Metaphor

Think of a string as a **beaded necklace**:

- Each bead is a character
- Beads are arranged in a specific order
- You can examine any bead by its position
- You can't change a bead without restringing the whole necklace (immutability)
- You can cut the necklace and restring portions (slicing)

String methods are like jewelry tools: cutters for splitting, magnifying glasses for searching, polishing cloths for cleaning.

---

## The Technical Reality

### Strings Are Immutable Sequences

Strings are **sequences** (like lists) but **immutable** (can't be changed):

~~~python runnable
text = "Hello"

# Access by index (like lists)
print(text[0])    # 'H'
print(text[-1])   # 'o'

# Iterate (like lists)
for char in text:
    print(char, end=" ")  # H e l l o

print()

# But can't modify in place
# text[0] = "J"  # TypeError: 'str' does not support item assignment

# Must create a new string
new_text = "J" + text[1:]
print(new_text)  # "Jello"
~~~

### Unicode and Encoding

Python 3 strings are Unicode by defaultâ€”they can hold any character:

~~~python runnable
# Emojis, Chinese, Greekâ€”all work
text = "Hello ä½ å¥½ Î“ÎµÎ¹Î¬ ðŸŽ‰"
print(text)
print(len(text))  # Counts characters, not bytes

# Each character has a code point
print(ord("A"))      # 65
print(chr(65))       # 'A'
print(ord("ä½ "))     # 20320
print(hex(ord("ðŸŽ‰")))  # 0x1f389
~~~

---

## The Code

### String Creation

~~~python runnable
# Different quote styles (all equivalent)
single = 'Hello'
double = "Hello"
triple_single = '''Hello'''
triple_double = """Hello"""

# Triple quotes preserve newlines and formatting
multiline = """
    This is a
    multiline string.
    Indentation is preserved!
"""
print(multiline)

# Raw strings (ignore escape sequences)
path = r"C:\Users\name\documents"  # Backslashes are literal
print(path)

# Escape sequences
escaped = "Tab:\tNewline:\nQuote:\""
print(escaped)
~~~

### String Methods: Searching

~~~python runnable
text = "The quick brown fox jumps over the lazy dog"

# Find substring (returns index, or -1 if not found)
print(text.find("fox"))      # 16
print(text.find("cat"))      # -1

# Find from the end
print(text.rfind("o"))       # 41 (last 'o')

# Check if contains (use 'in' operator)
print("fox" in text)         # True
print("cat" in text)         # False

# Count occurrences
print(text.count("o"))       # 4

# Check start/end
print(text.startswith("The"))     # True
print(text.endswith("dog"))       # True
print(text.startswith(("A", "The")))  # True (tuple of options)
~~~

### String Methods: Modifying (Returns New String)

~~~python runnable
text = "  Hello, World!  "

# Case conversion
print(text.upper())          # "  HELLO, WORLD!  "
print(text.lower())          # "  hello, world!  "
print(text.title())          # "  Hello, World!  "
print(text.capitalize())     # "  hello, world!  " (only first char)
print(text.swapcase())       # "  hELLO, wORLD!  "

# Whitespace removal
print(text.strip())          # "Hello, World!" (both sides)
print(text.lstrip())         # "Hello, World!  " (left only)
print(text.rstrip())         # "  Hello, World!" (right only)

# Strip specific characters
print("...hello...".strip("."))  # "hello"

# Replacement
print(text.replace("World", "Python"))  # "  Hello, Python!  "
print("aaa".replace("a", "b", 2))       # "bba" (max 2 replacements)
~~~

### String Methods: Splitting and Joining

~~~python runnable
# Split into list
text = "apple,banana,cherry"
fruits = text.split(",")
print(fruits)  # ['apple', 'banana', 'cherry']

# Split with limit
print("a,b,c,d".split(",", 2))  # ['a', 'b', 'c,d']

# Split on whitespace (default)
sentence = "Hello   World"
words = sentence.split()  # Splits on any whitespace, removes empty
print(words)  # ['Hello', 'World']

# Split lines
multiline = "Line 1\nLine 2\nLine 3"
lines = multiline.splitlines()
print(lines)  # ['Line 1', 'Line 2', 'Line 3']

# Join list into string
fruits = ['apple', 'banana', 'cherry']
result = ", ".join(fruits)
print(result)  # "apple, banana, cherry"

# Join with different separators
print("-".join(fruits))   # "apple-banana-cherry"
print("".join(fruits))    # "applebananacherry"
print("\n".join(fruits))  # Each on new line
~~~

### String Methods: Validation

~~~python runnable
# Check content type
print("123".isdigit())       # True
print("abc".isalpha())       # True
print("abc123".isalnum())    # True
print("   ".isspace())       # True
print("Hello".istitle())     # True
print("HELLO".isupper())     # True
print("hello".islower())     # True

# Practical validation
def is_valid_stock_symbol(symbol):
    """Check if valid US stock symbol (1-5 uppercase letters)."""
    return symbol.isalpha() and symbol.isupper() and 1 <= len(symbol) <= 5

print(is_valid_stock_symbol("AAPL"))   # True
print(is_valid_stock_symbol("aapl"))   # False (lowercase)
print(is_valid_stock_symbol("A1"))     # False (has number)
print(is_valid_stock_symbol("TOOLONG"))  # False (>5 chars)
~~~

### String Methods: Padding and Alignment

~~~python runnable
text = "42"

# Padding
print(text.zfill(5))         # "00042" (zero-fill)
print(text.ljust(5, "-"))    # "42---" (left justify)
print(text.rjust(5, "-"))    # "---42" (right justify)
print(text.center(5, "-"))   # "-42--" (center)

# Useful for formatting reports
stocks = [("AAPL", 175.50), ("GOOGL", 140.25), ("MSFT", 380.00)]
print("\nFormatted Report:")
for symbol, price in stocks:
    print(f"{symbol.ljust(6)} ${price:>8.2f}")
~~~

### Slicing Strings

~~~python runnable
text = "Python Programming"

# Basic slicing [start:stop:step]
print(text[0:6])     # "Python" (chars 0-5)
print(text[7:])      # "Programming" (char 7 to end)
print(text[:6])      # "Python" (start to char 5)
print(text[-11:])    # "Programming" (last 11 chars)

# With step
print(text[::2])     # "Pto rgamn" (every 2nd char)
print(text[::-1])    # "gnimmargorP nohtyP" (reversed)

# Extract parts
filename = "report_2024_Q3.csv"
name_only = filename[:-4]    # "report_2024_Q3" (remove .csv)
extension = filename[-3:]     # "csv"
print(f"Name: {name_only}, Extension: {extension}")
~~~

### F-Strings (Formatted String Literals)

~~~python runnable
name = "AAPL"
price = 175.5678
change = 0.0234

# Basic interpolation
print(f"Stock: {name}")

# Expressions inside braces
print(f"Double price: {price * 2}")
print(f"Price rounded: {round(price, 2)}")

# Format specifiers
print(f"Price: ${price:.2f}")           # 2 decimal places
print(f"Change: {change:.2%}")          # As percentage
print(f"Price: ${price:>10.2f}")        # Right-align in 10 chars
print(f"Symbol: {name:<10}")            # Left-align in 10 chars
print(f"Large: {1234567:,}")            # Thousands separator
print(f"Change: {change:+.2%}")         # Always show sign

# Debug format (Python 3.8+)
x = 42
print(f"{x=}")           # "x=42"
print(f"{price=:.2f}")   # "price=175.57"

# Nested expressions
data = {"symbol": "AAPL", "price": 175.50}
print(f"Stock: {data['symbol']} at ${data['price']:.2f}")
~~~

### Common String Patterns

~~~python runnable
# Pattern 1: Parse key=value pairs
config = "host=localhost;port=5432;db=stocks"
pairs = config.split(";")
settings = {}
for pair in pairs:
    key, value = pair.split("=")
    settings[key] = value
print(settings)  # {'host': 'localhost', 'port': '5432', 'db': 'stocks'}

# Pattern 2: Clean and normalize input
user_input = "  AAPL, GOOGL,  msft , AMZN  "
symbols = [s.strip().upper() for s in user_input.split(",")]
print(symbols)  # ['AAPL', 'GOOGL', 'MSFT', 'AMZN']

# Pattern 3: Build strings incrementally
parts = []
parts.append("SELECT * FROM stocks")
parts.append("WHERE sector = 'tech'")
parts.append("ORDER BY price DESC")
query = " ".join(parts)
print(query)

# Pattern 4: Template replacement
template = "Hello, {name}! Your balance is ${balance:.2f}."
message = template.format(name="Alice", balance=1234.56)
print(message)

# Pattern 5: Extract between delimiters
text = "Price: $175.50 (USD)"
start = text.find("$") + 1
end = text.find(" ", start)
price_str = text[start:end]
print(f"Extracted price: {price_str}")
~~~

---

## The Exercise

### Exercise 4a.1: Stock Symbol Validator
~~~python exercise id="4a.1"
def validate_symbol(symbol: str) -> tuple[bool, str]:
    """
    Validate a stock symbol.

    Rules:
    - Must be 1-5 characters
    - Must be all letters
    - Must be uppercase (or convert to uppercase)

    Returns: (is_valid, cleaned_symbol_or_error_message)
    """
    # YOUR CODE HERE
    pass

# Test cases
print(validate_symbol("AAPL"))      # (True, "AAPL")
print(validate_symbol("aapl"))      # (True, "AAPL") - auto-uppercase
print(validate_symbol("A1"))        # (False, "Must contain only letters")
print(validate_symbol("TOOLONG"))   # (False, "Must be 1-5 characters")
print(validate_symbol(""))          # (False, "Must be 1-5 characters")
~~~

### Exercise 4a.2: Parse Financial Data
~~~python exercise id="4a.2"
def parse_trade(trade_string: str) -> dict:
    """
    Parse a trade string into components.

    Format: "BUY 100 AAPL @ 175.50"
    Returns: {"action": "BUY", "quantity": 100, "symbol": "AAPL", "price": 175.50}
    """
    # YOUR CODE HERE
    pass

# Test
trade = "BUY 100 AAPL @ 175.50"
print(parse_trade(trade))
# Should print: {'action': 'BUY', 'quantity': 100, 'symbol': 'AAPL', 'price': 175.50}

trade2 = "SELL 50 GOOGL @ 140.25"
print(parse_trade(trade2))
~~~

### Exercise 4a.3: Format Portfolio Report
~~~python exercise id="4a.3"
def format_portfolio(holdings: list[tuple]) -> str:
    """
    Format holdings into a nice report.

    Input: [("AAPL", 100, 175.50), ("GOOGL", 50, 140.25), ...]
    Each tuple: (symbol, shares, price)

    Output should look like:
    =====================================
    PORTFOLIO SUMMARY
    =====================================
    Symbol    Shares    Price      Value
    -------------------------------------
    AAPL         100   $175.50  $17,550.00
    GOOGL         50   $140.25   $7,012.50
    -------------------------------------
    TOTAL                       $24,562.50
    =====================================
    """
    # YOUR CODE HERE
    pass

holdings = [
    ("AAPL", 100, 175.50),
    ("GOOGL", 50, 140.25),
    ("MSFT", 25, 380.00),
]
print(format_portfolio(holdings))
~~~

### Exercise 4a.4: CSV Line Parser
~~~python exercise id="4a.4"
def parse_csv_line(line: str) -> list[str]:
    """
    Parse a CSV line handling quoted fields.

    Simple rules:
    - Fields separated by commas
    - Fields can be quoted with double quotes
    - Quoted fields can contain commas

    Example: 'AAPL,"Apple, Inc.",175.50' -> ['AAPL', 'Apple, Inc.', '175.50']
    """
    # YOUR CODE HERE (this is tricky!)
    pass

# Test
print(parse_csv_line('AAPL,Apple,175.50'))
# ['AAPL', 'Apple', '175.50']

print(parse_csv_line('AAPL,"Apple, Inc.",175.50'))
# ['AAPL', 'Apple, Inc.', '175.50']
~~~

### Exercise 4a.5: Text Statistics
~~~python exercise id="4a.5"
def analyze_text(text: str) -> dict:
    """
    Analyze text and return statistics.

    Return:
    - character_count (excluding spaces)
    - word_count
    - sentence_count (count periods, exclamation marks, question marks)
    - average_word_length
    - most_common_word (lowercase, excluding common words like 'the', 'a', 'is')
    """
    # YOUR CODE HERE
    pass

sample = """
Python is a great programming language. Python is used for web development.
Python is also popular for data science! Is Python easy to learn? Yes, it is.
"""
print(analyze_text(sample))
~~~

---

## The Gotchas

### Gotcha 1: Strings Are Immutable

~~~python runnable
text = "Hello"

# This creates a NEW string each time
text = text + " World"  # New string created
text += "!"             # Another new string

# For many concatenations, this is slow
# BAD (creates many intermediate strings)
result = ""
for i in range(1000):
    result += str(i)  # Creates 1000 intermediate strings!

# GOOD (build list, join once)
parts = []
for i in range(1000):
    parts.append(str(i))
result = "".join(parts)

# BETTER (list comprehension)
result = "".join(str(i) for i in range(1000))
print(result[:50] + "...")
~~~

### Gotcha 2: split() vs split(" ")

~~~python runnable
text = "hello   world"

# split() with no args: splits on ANY whitespace, removes empty strings
print(text.split())      # ['hello', 'world']

# split(" "): splits on exactly one space, keeps empty strings
print(text.split(" "))   # ['hello', '', '', 'world']

# Usually you want split() without arguments
~~~

### Gotcha 3: String Comparison Is Lexicographic

~~~python runnable
# Compares character by character using Unicode values
print("apple" < "banana")   # True ('a' < 'b')
print("Apple" < "apple")    # True ('A' = 65, 'a' = 97)
print("10" < "9")           # True! ('1' < '9')
print("100" < "20")         # True! (compares '1' to '2')

# For numeric strings, convert to numbers first
prices = ["100", "20", "9", "1000"]
print(sorted(prices))                    # ['100', '1000', '20', '9'] - wrong!
print(sorted(prices, key=int))           # ['9', '20', '100', '1000'] - correct!
~~~

### Gotcha 4: find() Returns -1, index() Raises Exception

~~~python runnable
text = "hello"

# find() returns -1 if not found
pos = text.find("x")
print(pos)  # -1

# index() raises ValueError if not found
try:
    pos = text.index("x")
except ValueError as e:
    print(f"Error: {e}")

# Be careful with -1 in slicing!
pos = text.find("x")
print(text[:pos])  # "hell" - not what you want! ([:âˆ’1] = all but last)

# Always check the result
pos = text.find("x")
if pos != -1:
    print(text[:pos])
else:
    print("Not found")
~~~

### Gotcha 5: in vs find for Checking Existence

~~~python runnable
text = "hello world"

# Use 'in' for boolean check (more readable)
if "world" in text:
    print("Found it!")

# Use find/index when you need the position
pos = text.find("world")
if pos != -1:
    print(f"Found at position {pos}")
~~~

---

## Real World Application: Log Parser

~~~python runnable
# Parsing server logs is a common real-world task
log_line = '2024-01-15 10:23:45 INFO [trading] Order executed: BUY 100 AAPL @ 175.50'

def parse_log_line(line: str) -> dict:
    """Parse a log line into components."""
    # Split on spaces, but we need to be careful with the message part
    parts = line.split(" ", 4)  # Split into max 5 parts

    date = parts[0]
    time = parts[1]
    level = parts[2]
    component = parts[3].strip("[]")
    message = parts[4] if len(parts) > 4 else ""

    return {
        "timestamp": f"{date} {time}",
        "level": level,
        "component": component,
        "message": message
    }

parsed = parse_log_line(log_line)
print(parsed)

# Filter logs by level
logs = [
    '2024-01-15 10:23:45 INFO [trading] Order executed',
    '2024-01-15 10:23:46 ERROR [api] Connection timeout',
    '2024-01-15 10:23:47 WARNING [trading] High volatility detected',
    '2024-01-15 10:23:48 INFO [api] Reconnected',
]

errors = [log for log in logs if " ERROR " in log]
print(f"\nFound {len(errors)} error(s):")
for error in errors:
    print(f"  {error}")
~~~

---

## Key Takeaways

1. Strings are **immutable sequences**â€”methods return new strings
2. Use `split()` (no args) to split on whitespace; `split(",")` for specific delimiter
3. Use `join()` to combine lists into strings efficiently
4. F-strings (`f"..."`) are the modern way to format strings
5. Use `in` for existence checks, `find()`/`index()` when you need position
6. String comparisons are lexicographicâ€”convert to numbers for numeric comparison
7. For many concatenations, build a list and `join()` at the end

---

## Next Lesson

Now that you can manipulate text, let's learn to make decisions based on data: **Control Flow (if/else)**.
