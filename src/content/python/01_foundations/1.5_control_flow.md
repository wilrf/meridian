---
title: "Control Flow (if/else)"
phase: 1
order: 5
requires: []
prev: "1.4_operators"
next: "1.6_loops"
---

# Lesson 5: Control Flow (if/else)

## The Problem

So far, your programs run every line from top to bottom, always the same way. But real programs need to make decisions: "If the price drops below $100, sell. Otherwise, hold." Control flow lets your code take different paths based on conditions.

---

## The Metaphor

Think of control flow like a choose-your-own-adventure book:

- You're reading along (executing code)
- You hit a decision point (if statement)
- Based on some condition, you flip to different pages (different code blocks)
- Eventually, paths might merge back together

Or like a flowchart: decision diamonds that branch into different directions based on yes/no answers.

---

## The Technical Reality

### Indentation Is Syntax

Unlike most languages that use `{ }` braces, Python uses **indentation** to define code blocks. This isn't just style—it's syntax.

```python
if condition:
    # This indented block belongs to the if
    do_something()
    do_another_thing()
# This is outside the if (back to original indentation)
continue_normally()
```

The Python style guide (PEP 8) mandates **4 spaces** for indentation. Not tabs, not 2 spaces—4 spaces.

### Truthiness Evaluation

When Python evaluates a condition, it converts the value to boolean using these rules:

**Falsy values** (evaluate to `False`):
- `False`
- `None`
- Zero: `0`, `0.0`, `0j`
- Empty sequences: `""`, `[]`, `()`, `{}`
- Objects with `__bool__()` returning `False` or `__len__()` returning `0`

**Everything else is truthy.**

This means you can write:
```python
if my_list:  # Instead of: if len(my_list) > 0
    process(my_list)
```

---

## The Code

### Basic if Statement

~~~python runnable
price = 150

if price > 100:
    print("Price is high")
~~~

### if-else

~~~python runnable
price = 80

if price > 100:
    print("Price is high")
else:
    print("Price is low or moderate")
~~~

### if-elif-else

~~~python runnable
price = 150

if price > 200:
    signal = "sell"
elif price > 100:
    signal = "hold"
elif price > 50:
    signal = "watch"
else:
    signal = "buy"

print(f"Signal: {signal}")  # hold
~~~

**Important:** Only one block executes. Once a condition is `True`, the rest are skipped.

### Nested Conditions

~~~python runnable
price = 150
volume = 2000000

if price < 200:
    if volume > 1000000:
        print("Good entry point")
    else:
        print("Low volume - wait")
else:
    print("Too expensive")
~~~

Often, nested conditions can be flattened with `and`:
~~~python runnable
price = 150
volume = 2000000

if price < 200 and volume > 1000000:
    print("Good entry point")
elif price < 200:
    print("Low volume - wait")
else:
    print("Too expensive")
~~~

### Conditional Expressions (Ternary)

~~~python runnable
# One-liner for simple conditions
price = 150
status = "expensive" if price > 100 else "affordable"
print(status)  # expensive

# Can be chained (but gets hard to read)
score = 85
grade = "A" if score >= 90 else "B" if score >= 80 else "C" if score >= 70 else "F"
print(f"Score {score} = Grade {grade}")

# Better to use regular if-elif for complex cases
~~~

### Match Statement (Python 3.10+)

Pattern matching—like `switch` in other languages, but more powerful:

~~~python runnable
def get_trading_action(signal):
    match signal:
        case "buy":
            return "Place buy order"
        case "sell":
            return "Place sell order"
        case "hold":
            return "Do nothing"
        case _:  # Default case (underscore matches anything)
            return "Unknown signal"

print(get_trading_action("buy"))  # Place buy order
print(get_trading_action("sell"))
print(get_trading_action("unknown"))
~~~

Pattern matching can also destructure:
~~~python runnable
def analyze_trade(trade):
    match trade:
        case {"type": "buy", "amount": amount}:
            return f"Buying {amount} shares"
        case {"type": "sell", "amount": amount}:
            return f"Selling {amount} shares"
        case _:
            return "Invalid trade"

print(analyze_trade({"type": "buy", "amount": 100}))
print(analyze_trade({"type": "sell", "amount": 50}))
~~~

---

## The Exercise

### Exercise 5.1: Trading Signal
~~~python exercise id="5.1"
price = 145.00
moving_average = 150.00
volume = 2500000
earnings_positive = True

# Write conditions to determine signal:
# - "strong buy" if price < moving_average AND volume > 2M AND earnings positive
# - "buy" if price < moving_average AND volume > 1M
# - "hold" if price is within 5% of moving_average (above or below)
# - "sell" otherwise

# YOUR CODE HERE

~~~

### Exercise 5.2: Grade Calculator
~~~python exercise id="5.2"
def calculate_grade(score):
    """
    Return letter grade based on score:
    90-100: A
    80-89: B
    70-79: C
    60-69: D
    Below 60: F

    Also handle invalid inputs (negative or > 100)
    """
    pass  # Your code here

# Test with: 95, 82, 70, 55, -5, 105
for score in [95, 82, 70, 55, -5, 105]:
    print(f"{score}: {calculate_grade(score)}")
~~~

### Exercise 5.3: Fizz Buzz (Classic)
Write a program that prints numbers 1 to 100, but:
- For multiples of 3, print "Fizz"
- For multiples of 5, print "Buzz"
- For multiples of both 3 and 5, print "FizzBuzz"
- Otherwise, print the number

~~~python exercise id="5.3"
# Print FizzBuzz for numbers 1-20 (use 100 for full challenge)

# YOUR CODE HERE

~~~

### Exercise 5.4: Risk Classifier
~~~python exercise id="5.4" validate="assert risk == 'medium'"
# Classify investment risk based on volatility and beta
volatility = 0.25  # 25% annualized volatility
beta = 1.3         # Market correlation

# Risk levels:
# "high" - volatility > 0.3 OR beta > 1.5
# "medium" - volatility > 0.15 OR beta > 1.0
# "low" - everything else
# But if volatility < 0.1 AND beta < 0.5, override to "very low"

risk = None  # Your code here

print(f"Risk level: {risk}")
~~~

### Exercise 5.5: Leap Year Calculator

~~~python exercise id="5.5" validate="assert is_leap_year(2024) == True and is_leap_year(2023) == False and is_leap_year(1900) == False and is_leap_year(2000) == True"
def is_leap_year(year: int) -> bool:
    """
    Determine if a year is a leap year.

    Rules:
    - Divisible by 4 → leap year
    - EXCEPT divisible by 100 → NOT a leap year
    - EXCEPT divisible by 400 → IS a leap year

    Examples:
    - 2024: divisible by 4 → leap year
    - 1900: divisible by 100 but not 400 → NOT leap year
    - 2000: divisible by 400 → leap year
    """
    # Your code here
    pass

# Test cases
for year in [2024, 2023, 1900, 2000, 2100]:
    print(f"{year}: {'Leap year' if is_leap_year(year) else 'Not leap year'}")
~~~

### Exercise 5.6: Password Validator

~~~python exercise id="5.6" validate="assert validate_password('Abc123!x') == True and validate_password('short') == False"
def validate_password(password: str) -> bool:
    """
    Check if password meets security requirements:
    1. At least 8 characters long
    2. Contains at least one uppercase letter
    3. Contains at least one lowercase letter
    4. Contains at least one digit
    5. Contains at least one special character (!@#$%^&*)

    Returns True if all requirements met, False otherwise.
    """
    # Your code here
    # Hint: Use any() with generator expressions, or simple loops
    pass

# Test cases
passwords = ["Abc123!x", "short", "NOLOWERCASE1!", "NoSpecial123", "no_upper_123!"]
for pwd in passwords:
    result = "Valid" if validate_password(pwd) else "Invalid"
    print(f"'{pwd}': {result}")
~~~

### Exercise 5.7: Tax Bracket Calculator

~~~python exercise id="5.7" validate="assert abs(calculate_tax(50000) - 6748.0) < 1 and abs(calculate_tax(100000) - 17400.0) < 1"
def calculate_tax(income: float) -> float:
    """
    Calculate US federal income tax (simplified 2024 brackets).

    Brackets (single filer):
    - $0 - $11,600: 10%
    - $11,601 - $47,150: 12%
    - $47,151 - $100,525: 22%
    - $100,526 - $191,950: 24%
    - Above: 32%

    Note: Tax is MARGINAL - each bracket only applies to income IN that bracket.
    Example: $50,000 income pays:
    - 10% on first $11,600 = $1,160
    - 12% on next $35,550 ($11,601 to $47,150) = $4,266
    - 22% on remaining $2,850 ($47,151 to $50,000) = $627
    - Total: $6,053
    """
    # Your code here
    pass

# Test cases
for income in [10000, 50000, 100000, 200000]:
    tax = calculate_tax(income)
    effective_rate = tax / income * 100 if income > 0 else 0
    print(f"Income: ${income:,} → Tax: ${tax:,.2f} (Effective rate: {effective_rate:.1f}%)")
~~~

---

## The Gotchas

### Gotcha 1: Assignment vs Comparison

```python
# WRONG - this assigns, doesn't compare
if x = 5:  # SyntaxError in Python (thankfully!)
    pass

# RIGHT - comparison
if x == 5:
    pass
```

Python protects you from this mistake (unlike C/JavaScript).

### Gotcha 2: Empty Blocks

```python
# This fails - Python requires something in a block
if condition:
    # TODO: implement later

# Use 'pass' as a placeholder
if condition:
    pass  # Do nothing for now
```

### Gotcha 3: Floating Point Comparisons

~~~python runnable
# DANGEROUS
if 0.1 + 0.2 == 0.3:
    print("Equal (dangerous check)")
else:
    print("Not equal! (0.1 + 0.2 != 0.3 due to float precision)")

# SAFE
import math
if math.isclose(0.1 + 0.2, 0.3):
    print("Equal (safe check with math.isclose)")
~~~

### Gotcha 4: Chained Comparisons and `or`

```python
# WRONG - doesn't do what you think
if answer == "yes" or "y":  # Always True! "y" is truthy
    pass

# RIGHT
if answer == "yes" or answer == "y":
    pass

# BETTER
if answer in ("yes", "y"):
    pass
```

### Gotcha 5: Boolean Operator Precedence

```python
# 'not' binds tighter than 'and' which binds tighter than 'or'
# This:
if a or b and not c:
    pass

# Means:
if a or (b and (not c)):
    pass

# Use parentheses to be clear!
if (a or b) and not c:  # If you meant this
    pass
```

---

## Key Takeaways

1. Indentation defines code blocks—4 spaces, no tabs
2. Use truthiness: `if my_list:` instead of `if len(my_list) > 0:`
3. `elif` prevents redundant checks and makes "exactly one" obvious
4. Ternary (`x if condition else y`) is for simple cases only
5. `match` (Python 3.10+) is powerful for pattern matching
6. Watch out for `or` with values: `"yes" or "y"` is not `answer == "yes" or answer == "y"`

---

## Next Lesson

Now that your code can make decisions, let's make it repeat actions: **Loops**.
