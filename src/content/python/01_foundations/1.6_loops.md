---
title: "Loops"
phase: 1
order: 6
requires: []
prev: "1.5_control_flow"
next: "1.7_project_number_analyzer"
---

# Lesson 6: Loops

## The Problem

Imagine calculating the average of 1,000 stock prices. Without loops, you'd write 1,000 addition statements. Loops let you repeat code—process every item in a collection, retry until something works, or run until a condition changes.

---

## The Metaphor

**`for` loop:** Like reading through a stack of documents. Pick up the first one, process it, pick up the next one, process it, continue until the stack is empty. You know how many documents exist before starting.

**`while` loop:** Like waiting for a bus. Keep checking "is the bus here?" If no, wait a bit and check again. You don't know how long you'll wait—you just keep going until the condition is met (or you give up).

---

## The Technical Reality

### Iteration Protocol

Python's `for` loop doesn't work like C's `for(i=0; i<n; i++)`. Instead, it uses the **iterator protocol**:

1. Call `iter()` on the collection to get an **iterator**
2. Repeatedly call `next()` on the iterator to get values
3. When `StopIteration` is raised, the loop ends

~~~python runnable
# What 'for x in [1,2,3]' actually does:
iterator = iter([1, 2, 3])
while True:
    try:
        x = next(iterator)
        print(x)
    except StopIteration:
        break
~~~

This means **anything** that implements `__iter__()` can be looped over: lists, strings, files, database cursors, infinite generators...

### Range Is Lazy

`range()` doesn't create a list—it generates numbers on demand:

~~~python runnable
# This uses almost no memory (just stores start, stop, step)
for i in range(1_000_000_000):
    if i > 5:
        break
    print(i)

# This would crash (tries to create billion-element list)
# for i in list(range(1_000_000_000)):
~~~

---

## The Code

### for Loop Basics

~~~python runnable
# Iterate over a list
prices = [100, 150, 125, 175]
for price in prices:
    print(f"Price: ${price}")

print()  # blank line

# Iterate over a string
for char in "AAPL":
    print(char)  # A, A, P, L

print()

# Iterate over a range
print("range(5):", end=" ")
for i in range(5):  # 0, 1, 2, 3, 4
    print(i, end=" ")

print("\nrange(0, 10, 2):", end=" ")
for i in range(0, 10, 2):  # 0, 2, 4, 6, 8
    print(i, end=" ")
~~~

### Enumerate: Index + Value

~~~python runnable
stocks = ["AAPL", "GOOGL", "MSFT"]

# BAD: using range to get index
print("Using range(len()):")
for i in range(len(stocks)):
    print(f"{i}: {stocks[i]}")

# GOOD: enumerate gives you both
print("\nUsing enumerate():")
for i, stock in enumerate(stocks):
    print(f"{i}: {stock}")

# Start from different number
print("\nWith start=1:")
for i, stock in enumerate(stocks, start=1):
    print(f"{i}: {stock}")  # 1: AAPL, 2: GOOGL, 3: MSFT
~~~

### while Loop

~~~python runnable
# Basic while
count = 0
while count < 5:
    print(count)
    count += 1
~~~

Waiting for condition (common in automation):
```python
# Pseudo-code example (fetch_price() is imaginary)
import time
attempts = 0
max_attempts = 5

while attempts < max_attempts:
    price = fetch_price()  # Imagine this calls an API
    if price is not None:
        print(f"Got price: {price}")
        break
    attempts += 1
    time.sleep(1)  # Wait 1 second before retry
else:
    print("Failed to fetch price")  # See 'else' clause below
```

### break, continue, else

~~~python runnable
prices = [100, 150, 125, 250, 175]

# break: exit the loop immediately
print("Using break:")
for price in prices:
    if price > 200:
        print("Found expensive stock!")
        break  # Stop searching
    print(f"Checking {price}...")

# continue: skip to next iteration
print("\nUsing continue (skip negatives):")
prices_with_errors = [100, -1, 150, -5, 200]
for price in prices_with_errors:
    if price < 0:
        continue  # Skip invalid prices
    print(f"Processing {price}")

# else: runs if loop completes WITHOUT break
print("\nUsing else clause:")
for price in prices:
    if price > 1000:
        print("Found very expensive stock!")
        break
else:
    print("No stocks over $1000 found")  # Only if no break occurred
~~~

The `else` clause is unusual—it runs when the loop finishes "naturally" (no `break`). Think of it as "if we didn't find what we were looking for."

### Nested Loops

~~~python runnable
# Cartesian product
stocks = ["AAPL", "GOOGL"]
actions = ["buy", "sell", "hold"]

for stock in stocks:
    for action in actions:
        print(f"{action} {stock}")
~~~

### List Comprehensions (Preview)

Python's elegant way to build lists from loops:

~~~python runnable
# Traditional loop
squares = []
for x in range(10):
    squares.append(x ** 2)
print(f"Traditional: {squares}")

# List comprehension (same result)
squares = [x ** 2 for x in range(10)]
print(f"Comprehension: {squares}")

# With condition
even_squares = [x ** 2 for x in range(10) if x % 2 == 0]
print(f"Even squares: {even_squares}")

# We'll cover comprehensions deeply in Phase 2
~~~

---

## The Exercise

### Exercise 6.1: Sum and Average
~~~python exercise id="6.1"
prices = [142.50, 145.30, 139.80, 151.20, 148.60, 143.90, 150.40]

# Calculate:
# 1. Sum of all prices (without using sum())
# 2. Average price
# 3. Highest price (without using max())
# 4. Lowest price (without using min())

# YOUR CODE HERE

~~~

### Exercise 6.2: Find the Outlier
~~~python exercise id="6.2"
data = [100, 102, 98, 101, 99, 103, 250, 97, 102, 100]

# Find and print the first value that's more than 50% above the average
# Use break when found
# If none found, print "No outliers"

# YOUR CODE HERE

~~~

### Exercise 6.3: Multiplication Table
Print a 10x10 multiplication table:
```
1   2   3   4   5   6   7   8   9   10
2   4   6   8   10  12  14  16  18  20
3   6   9   ...
```
Hint: Use f-strings with width formatting: `f"{value:4}"`

~~~python exercise id="6.3"
# Print a 10x10 multiplication table

# YOUR CODE HERE

~~~

### Exercise 6.4: Prime Numbers
~~~python exercise id="6.4"
# Print all prime numbers between 2 and 100
# A prime number is only divisible by 1 and itself

# Hint: for each number n, check if any number from 2 to n-1 divides it evenly
# Use the else clause on the inner loop

# YOUR CODE HERE

~~~

### Exercise 6.5: Convergence
~~~python exercise id="6.5" validate="assert abs(guess**2 - 2) < 0.0001 and iterations < 20"
# Calculate square root of 2 using Newton's method
# Start with guess = 1.0
# New guess = (guess + 2/guess) / 2
# Stop when abs(guess**2 - 2) < 0.0001

# How many iterations does it take?

guess = 1.0
iterations = 0

# YOUR CODE HERE

print(f"sqrt(2) ≈ {guess}")
print(f"Iterations: {iterations}")
print(f"Verification: {guess}² = {guess**2}")
~~~

### Exercise 6.6: Running Maximum

~~~python exercise id="6.6" validate="assert running_max == [100, 100, 105, 110, 110, 120, 120]"
prices = [100, 95, 105, 110, 103, 120, 115]

# Calculate the running maximum at each point
# running_max[i] = max of all prices from index 0 to i
# Expected: [100, 100, 105, 110, 110, 120, 120]

running_max = []

# YOUR CODE HERE

print(f"Prices: {prices}")
print(f"Running max: {running_max}")
~~~

### Exercise 6.7: Pattern Detector

~~~python exercise id="6.7" validate="assert consecutive_up == 3 and longest_up_streak == 4"
prices = [100, 102, 105, 103, 101, 104, 108, 112, 115, 113]

# Find:
# 1. consecutive_up: Count of consecutive up days at the END of the series
# 2. longest_up_streak: Longest streak of consecutive up days anywhere

consecutive_up = 0
longest_up_streak = 0

# YOUR CODE HERE

print(f"Consecutive up days at end: {consecutive_up}")
print(f"Longest up streak: {longest_up_streak}")
~~~

### Exercise 6.8: Two-Sum Problem (Classic Interview Question)

~~~python exercise id="6.8" validate="assert find_two_sum([2, 7, 11, 15], 9) == (0, 1) or find_two_sum([2, 7, 11, 15], 9) == (1, 0)"
def find_two_sum(numbers: list, target: int) -> tuple | None:
    """
    Find two numbers in the list that add up to target.

    Args:
        numbers: List of integers
        target: Target sum

    Returns:
        Tuple of (index1, index2) if found, None if no solution

    Example:
        find_two_sum([2, 7, 11, 15], 9) → (0, 1)
        because numbers[0] + numbers[1] = 2 + 7 = 9
    """
    # Your code here
    # Hint: Use nested loops, or for a challenge, use a dict for O(n) solution
    pass

# Test cases
print(find_two_sum([2, 7, 11, 15], 9))   # (0, 1)
print(find_two_sum([3, 2, 4], 6))         # (1, 2)
print(find_two_sum([3, 3], 6))            # (0, 1)
print(find_two_sum([1, 2, 3], 10))        # None
~~~

### Exercise 6.9: Moving Average

~~~python exercise id="6.9" validate="assert len(moving_avg) == 5 and abs(moving_avg[0] - 101.0) < 0.01"
prices = [100, 102, 101, 103, 105, 104, 106]
window = 3

# Calculate the moving average with the given window size
# moving_avg[i] = average of prices[i:i+window]
# For window=3 and prices above:
# - moving_avg[0] = (100 + 102 + 101) / 3 = 101.0
# - moving_avg[1] = (102 + 101 + 103) / 3 = 102.0
# - etc.

moving_avg = []

# YOUR CODE HERE

print(f"Prices: {prices}")
print(f"Window: {window}")
print(f"Moving average: {[round(x, 2) for x in moving_avg]}")
~~~

### Exercise 6.10: FizzBuzz Extended (Divisibility Checker)

~~~python exercise id="6.10" validate="assert output[-1] == 'FizzBuzz' and output[0] == '1'"
# Enhanced FizzBuzz: Generate output for numbers 1 to 15
# Rules:
# - Divisible by 3: "Fizz"
# - Divisible by 5: "Buzz"
# - Divisible by both: "FizzBuzz"
# - Otherwise: the number as a string

# Store results in a list called 'output'
output = []

# YOUR CODE HERE

print(output)
~~~

---

## The Gotchas

### Gotcha 1: Modifying List While Iterating

```python
# DANGEROUS - unpredictable behavior
numbers = [1, 2, 3, 4, 5]
for n in numbers:
    if n % 2 == 0:
        numbers.remove(n)
print(numbers)  # [1, 3, 5]? No! [1, 3, 5] or [1, 2, 3, 4, 5] - undefined!

# SAFE - iterate over a copy
for n in numbers[:]:  # [:] creates a copy
    if n % 2 == 0:
        numbers.remove(n)

# BETTER - build a new list
numbers = [n for n in numbers if n % 2 != 0]
```

### Gotcha 2: range() Doesn't Include End

~~~python runnable
# Common mistake
print("range(1, 10):", end=" ")
for i in range(1, 10):  # 1 to 9, NOT 1 to 10!
    print(i, end=" ")

# If you want 1 to 10:
print("\nrange(1, 11):", end=" ")
for i in range(1, 11):
    print(i, end=" ")
~~~

### Gotcha 3: Infinite Loops

```python
# This never ends!
while True:
    print("Forever...")
    # Forgot to add break condition!

# Always ensure your while loop can terminate:
# 1. The condition can become False
# 2. There's a break statement that can trigger
```

### Gotcha 4: Off-by-One with enumerate

~~~python runnable
items = ["a", "b", "c"]

# Starts at 0 by default
print("Default (0-indexed):")
for i, item in enumerate(items):
    print(f"Index {i}: {item}")  # 0, 1, 2

# If you expect 1-based indexing:
print("\nWith start=1:")
for i, item in enumerate(items, start=1):
    print(f"Item #{i}: {item}")  # 1, 2, 3
~~~

### Gotcha 5: Loop Variable Scope

```python
# The loop variable persists after the loop!
for i in range(5):
    pass

print(i)  # 4 (not an error!)

# This can lead to subtle bugs
for item in items:
    if condition:
        found = item
        break

print(found)  # Works if found, NameError if not!

# Safer pattern:
found = None
for item in items:
    if condition:
        found = item
        break

if found is not None:
    print(found)
```

---

## Key Takeaways

1. `for` iterates over sequences; `while` runs until a condition is false
2. Use `enumerate()` instead of `range(len())` to get indices
3. `break` exits immediately; `continue` skips to next iteration
4. `else` on a loop runs only if no `break` occurred
5. Never modify a list while iterating over it
6. `range()` is lazy—it generates values on demand
7. Loop variables persist after the loop ends

---

## Next Lesson

You've mastered control flow and loops. Now it's time to put it all together: **Project: Number Analyzer**—your first real program combining everything from Phase 1.
