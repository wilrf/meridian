---
title: "Data Types"
phase: 1
order: 3
requires: []
prev: "1.2_variables_and_memory"
next: "1.4_operators"
---

# Lesson 3: Data Types

## The Problem

Not all data is the same. A stock price (150.50) is different from a company name ("Apple") is different from "yes or no" (True/False). Computers need to know what **kind** of data they're working with to:

1. Know how much memory to allocate
2. Know what operations are valid (you can divide numbers, but not words)
3. Know how to interpret the raw bits in memory

---

## The Metaphor

Think of data types like different types of containers:

- **Integers** are like counting chips—whole, indivisible units
- **Floats** are like measuring cups—they handle fractional amounts
- **Strings** are like beaded necklaces—a sequence of characters strung together
- **Booleans** are like light switches—only two states, on or off

You wouldn't pour liquid into a chip counter or string beads through a light switch. Each container has its purpose.

---

## The Technical Reality

### Everything Is an Object

In Python, **everything** is an object—including numbers. This is unusual among programming languages.

~~~python runnable
x = 42
print(type(x))        # <class 'int'>
print(x.bit_length()) # 6 - integers have methods!
~~~

Even `42` is an object with methods. This uniformity makes Python elegant but slightly slower than languages where numbers are "primitive."

### Type Hierarchy

```
object (everything inherits from this)
├── int (integers)
├── float (decimals)
├── bool (True/False - actually inherits from int!)
├── str (strings)
├── NoneType (the type of None)
├── list, dict, set, tuple (collections - later lessons)
└── ... (many more)
```

Surprising fact: `bool` inherits from `int`:
~~~python runnable
print(True + True)   # 2
print(False * 10)    # 0
print(isinstance(True, int))  # True
~~~

This is why `True` equals `1` and `False` equals `0` in numeric contexts.

---

## The Code

### Integers (`int`)

Whole numbers, positive or negative, with unlimited size.

~~~python runnable
shares = 100
balance = -500
huge = 10**100  # Python handles arbitrarily large integers
print(f"shares: {shares}, balance: {balance}")
print(f"huge number has {len(str(huge))} digits")

# Underscores for readability (Python 3.6+)
market_cap = 2_500_000_000_000  # 2.5 trillion
print(f"market_cap: {market_cap}")

# Different bases
binary = 0b1010      # 10 in decimal
octal = 0o17         # 15 in decimal
hexadecimal = 0xFF   # 255 in decimal
print(f"binary: {binary}, octal: {octal}, hex: {hexadecimal}")
~~~

### Floats (`float`)

Decimal numbers. Stored as 64-bit IEEE 754 floating point.

~~~python runnable
price = 150.50
percentage = 0.075
scientific = 6.022e23  # Avogadro's number
print(f"price: {price}, percentage: {percentage}")
print(f"scientific: {scientific}")

# Float limitations you MUST understand for finance
print(0.1 + 0.2)  # 0.30000000000000004 (not 0.3!)
~~~

**Why 0.1 + 0.2 isn't 0.3:** Computers use binary. Just like 1/3 = 0.333... goes on forever in decimal, 0.1 goes on forever in binary. The computer rounds, creating tiny errors.

~~~python runnable
# For financial calculations, use Decimal
from decimal import Decimal
price = Decimal("0.1") + Decimal("0.2")
print(price)  # 0.3 (exact)
~~~

### Strings (`str`)

Text data. Sequences of Unicode characters.

~~~python runnable
# Single or double quotes (no difference)
name = "Apple Inc"
print(name)

# Triple quotes for multi-line
description = """
Apple Inc. designs, manufactures, and markets
smartphones, personal computers, tablets, wearables,
and accessories worldwide.
"""
print(description)

# Escape characters
tab = "Col1\tCol2"        # Tab character
newline = "Line1\nLine2"  # Newline
print(tab)
print(newline)

# f-strings (Python 3.6+) - formatted string literals
stock = "AAPL"
price = 175.50
print(f"{stock} is trading at ${price}")  # AAPL is trading at $175.5
print(f"{stock} is trading at ${price:.2f}")  # $175.50 (2 decimal places)
~~~

### Booleans (`bool`)

Logical values. Only two possible values: `True` or `False`.

~~~python runnable
is_profitable = True
has_dividend = False

# Comparison operators return booleans
print(10 > 5)   # True
print(10 == 5)  # False
print(10 != 5)  # True

# Truthiness: what evaluates to False?
print("Falsy values:")
print(bool(0))        # False
print(bool(0.0))      # False
print(bool(""))       # False (empty string)
print(bool([]))       # False (empty list)
print(bool(None))     # False

# Everything else is True
print("\nTruthy values:")
print(bool(1))        # True
print(bool(-1))       # True (any non-zero number)
print(bool("hello"))  # True (any non-empty string)
print(bool([1,2,3]))  # True (any non-empty list)
~~~

### None (`NoneType`)

The absence of a value. Not the same as 0, "", or False.

```python
result = None

# Check for None with 'is', not '=='
if result is None:
    print("No result yet")

# Common use: optional parameters
def get_price(symbol, date=None):
    if date is None:
        date = today()  # Default to today
    # ...
```

---

## Type Conversion

~~~python runnable
# String to number
shares = int("100")       # 100
price = float("150.50")   # 150.5
print(f"shares: {shares}, price: {price}")

# Number to string
price_str = str(150.50)   # "150.5"
print(f"price_str: {price_str}, type: {type(price_str)}")

# Converting float string to int (must go through float first)
value = int(float("100.5"))  # 100
print(f"int(float('100.5')): {value}")

# Rounding vs truncating
print(f"int(3.9): {int(3.9)}")      # 3 (truncates toward zero)
print(f"round(3.9): {round(3.9)}")    # 4 (rounds to nearest)
print(f"round(3.14159, 2): {round(3.14159, 2)}")  # 3.14
~~~

Be careful with invalid conversions:
```python
int("hello")  # ValueError: invalid literal
int("100.5")  # ValueError: can't convert float string to int
```

---

## The Exercise

### Exercise 3.1: Type Detective
For each value, predict its type, then verify with `type()`:
~~~python exercise id="3.1"
values = [
    42,
    42.0,
    "42",
    True,
    None,
    3 + 4,
    3 + 4.0,
    "3" + "4",
    10 / 2,
    10 // 2,
]

# Print the type of each value
for v in values:
    print(f"{repr(v):15} -> {type(v).__name__}")
~~~

### Exercise 3.2: Float Precision
~~~python exercise id="3.2"
# Why does this fail? How would you fix it for a financial application?
total = 0.0
for i in range(10):
    total += 0.1
print(f"total = {total}")
print(f"total == 1.0? {total == 1.0}")  # False! Why?

# YOUR FIX HERE: use Decimal for exact arithmetic
~~~

### Exercise 3.3: Type Conversion Pipeline
Write a program that:
1. Takes a string like "150.75"
2. Converts it to a float
3. Multiplies by 100 shares
4. Converts to int (truncating cents)
5. Converts back to a formatted string with dollar sign

~~~python exercise id="3.3"
price_string = "150.75"

# YOUR CODE HERE
# Step 1-5 conversion pipeline

~~~

### Exercise 3.4: f-string Formatting
Print a formatted table. Hint: f-strings can include format specifiers like `{value:>10.2f}`

~~~python exercise id="3.4" expected="AAPL    $175.50   +2.30%"
stocks = [
    ("AAPL", 175.50, 0.023),
    ("GOOGL", 140.25, -0.015),
    ("MSFT", 380.00, 0.008),
]

# Print formatted like:
# AAPL    $175.50   +2.30%
# GOOGL   $140.25   -1.50%
# MSFT    $380.00   +0.80%

# YOUR CODE HERE

~~~

### Exercise 3.5: Type-Safe Calculator

~~~python exercise id="3.5" validate="assert result == 'Error: cannot convert to number' or isinstance(result, float)"
def safe_calculate(value_str: str, multiplier: float) -> str | float:
    """
    Safely convert a string to float and multiply.

    Args:
        value_str: A string that might be a number
        multiplier: What to multiply by

    Returns:
        The result as a float, or "Error: cannot convert to number" if invalid
    """
    # Your code here:
    # 1. Try to convert value_str to float
    # 2. If successful, return value_str * multiplier
    # 3. If it fails (ValueError), return the error message
    pass

# Test cases
print(safe_calculate("150.50", 100))    # Should print: 15050.0
print(safe_calculate("invalid", 100))   # Should print: Error: cannot convert to number
print(safe_calculate("", 100))          # Should print: Error: cannot convert to number

result = safe_calculate("150.50", 100)
~~~

### Exercise 3.6: Boolean Logic Challenge

~~~python exercise id="3.6" validate="assert should_trade == True and risk_level == 'medium'"
# Given these market conditions
price = 145.00
volume = 2_500_000
is_market_open = True
previous_close = 142.00
volatility = 0.18

# Calculate:
# 1. price_change: percentage change from previous_close
# 2. is_up_day: True if price > previous_close
# 3. high_volume: True if volume > 1_000_000
# 4. should_trade: True if market is open AND (it's an up day OR high volume)
# 5. risk_level: "high" if volatility > 0.25, "medium" if > 0.10, else "low"

# Your code here:
price_change = None
is_up_day = None
high_volume = None
should_trade = None
risk_level = None

print(f"Price change: {price_change:.2%}")
print(f"Up day: {is_up_day}")
print(f"High volume: {high_volume}")
print(f"Should trade: {should_trade}")
print(f"Risk level: {risk_level}")
~~~

---

## The Gotchas

### Gotcha 1: Integer Division Changed

~~~python runnable
# Python 3
print(10 / 3)   # 3.333... (true division)
print(10 // 3)  # 3 (floor division)

# Python 2 (old, don't use)
# 10 / 3 would give 3, not 3.333...
~~~

Always use `//` when you explicitly want integer division.

### Gotcha 2: String Immutability

Strings cannot be changed in place:

```python
name = "Apple"
name[0] = "a"  # TypeError: 'str' does not support item assignment

# You must create a new string
name = "a" + name[1:]  # "apple"
```

### Gotcha 3: Boolean Comparisons

```python
# Don't compare booleans to True/False
if is_valid == True:  # Works but bad style
if is_valid:          # Pythonic

# Exception: when None is a valid value
result = some_function()  # Could return True, False, or None
if result is True:        # Explicitly check for True, not just truthy
    ...
```

### Gotcha 4: Numeric String Sorting

~~~python runnable
prices = ["100", "25", "200", "3"]
print(sorted(prices))  # ['100', '200', '25', '3'] - lexicographic!

# Convert to numbers first
print(sorted(prices, key=int))  # ['3', '25', '100', '200']
~~~

---

## Key Takeaways

1. Python has dynamic typing—variables can hold any type
2. Use `type()` to check a value's type
3. Floats have precision issues—use `Decimal` for money
4. `bool` is actually a subclass of `int`
5. Empty values are "falsy": `0`, `""`, `[]`, `None`, `False`
6. Strings are immutable—operations create new strings

---

## Next Lesson

Now that you understand data types, let's learn how to combine and manipulate them: **Operators and Expressions**.
