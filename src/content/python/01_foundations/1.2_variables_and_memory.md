---
title: "Variables and Memory"
phase: 1
order: 2
requires: []
prev: "1.1_what_is_python"
next: "1.3_data_types"
---

# Lesson 2: Variables and Memory

## The Problem

A program that can't remember anything is useless. If you calculate `10 + 5`, the result (15) vanishes immediately unless you store it somewhere. You need a way to save values and refer to them later.

---

## The Metaphor

Think of computer memory like a massive warehouse with numbered shelves.

**In languages like C:** You rent a specific shelf (memory address) and put your item there. You need to know the exact shelf number, and you're responsible for cleaning up when done.

**In Python:** You put a **label** (a sticky note) on an item. The warehouse figures out where to store it. You just remember the label name. When you're done with an item, Python automatically cleans it up (this is called "garbage collection").

A **variable** is just a label that points to a value stored somewhere in memory.

---

## The Technical Reality

This is where Python differs from many languages, and understanding this will save you hours of debugging.

### Variables Are References, Not Boxes

In Python, a variable doesn't "contain" a value—it **points to** a value.

~~~python runnable
x = 10
print(x)
~~~

What happens:
1. Python creates an integer object `10` somewhere in memory
2. Python creates a label `x` that points to that object

```
Variable x  ──────►  [Integer Object: 10]
(label)              (stored in memory at some address)
```

### The `id()` Function

Every object in Python has a unique identity—its memory address. You can see it:

~~~python runnable
x = 10
print(id(x))  # Something like 4341563696
~~~

### Multiple Labels, Same Object

~~~python runnable
x = 10
y = x
print(f"x = {x}, y = {y}")
~~~

Now both `x` and `y` point to the **same object**:

```
Variable x  ──┬───►  [Integer Object: 10]
Variable y  ──┘
```

Proof:
~~~python runnable
x = 10
y = x
print(id(x))  # 4341563696
print(id(y))  # 4341563696 (same!)
print(x is y)  # True - they're the same object
~~~

### Reassignment Creates New References

~~~python runnable
x = 10
y = x
x = 20  # x now points to a NEW object
print(f"x = {x}, y = {y}")  # y still points to 10
~~~

After this:
```
Variable x  ──────►  [Integer Object: 20]
Variable y  ──────►  [Integer Object: 10]
```

`y` still points to `10`. Reassigning `x` didn't change `y`.

### Why This Matters for ML/Finance

When you work with large datasets:
~~~python runnable
prices = [100, 200, 300]  # A big list
backup = prices  # NOT a copy! Same object!
prices[0] = 999
print(backup[0])  # 999 - backup changed too!
~~~

This is a common source of bugs. We'll cover how to make actual copies later.

---

## The Code

### Creating Variables

~~~python runnable
# No declaration needed - just assign
price = 100.50
name = "Apple Inc"
shares = 50
is_profitable = True

# Python infers the type from the value
print(type(price))       # <class 'float'>
print(type(name))        # <class 'str'>
print(type(shares))      # <class 'int'>
print(type(is_profitable))  # <class 'bool'>
~~~

### Naming Rules

```python
# Valid names
stock_price = 100
stockPrice = 100   # camelCase (valid but not Pythonic)
_private = 100     # underscore prefix (convention for "internal")
price2 = 100       # numbers OK (but not at start)

# Invalid names
2price = 100       # SyntaxError: can't start with number
stock-price = 100  # SyntaxError: hyphen not allowed
class = 100        # SyntaxError: 'class' is a reserved word
```

### Python Naming Convention (PEP 8)

```python
# Variables and functions: snake_case
stock_price = 100
total_shares = 50

# Constants (by convention, not enforced): SCREAMING_SNAKE_CASE
MAX_SHARES = 1000000
API_KEY = "abc123"

# Classes: PascalCase
class StockPortfolio:
    pass
```

### Multiple Assignment

~~~python runnable
# Assign multiple variables at once
x, y, z = 1, 2, 3
print(f"x={x}, y={y}, z={z}")

# Swap values (elegant Python idiom)
x, y = y, x  # No temp variable needed!
print(f"After swap: x={x}, y={y}")

# Unpack from a list
prices = [100, 200, 300]
first, second, third = prices
print(f"first={first}, second={second}, third={third}")
~~~

---

## The Exercise

### Exercise 2.1: Reference Investigation
~~~python exercise id="2.1"
# Run this code and explain what you see
a = [1, 2, 3]
b = a
a.append(4)
print(b)  # What prints? Why?
~~~

### Exercise 2.2: Integer Caching
Python does something surprising with small integers. Run this:
~~~python exercise id="2.2"
x = 256
y = 256
print(x is y)  # What do you get?

x = 257
y = 257
print(x is y)  # What about now? Why different?
~~~
Research: What is "integer interning" and why does Python do it?

### Exercise 2.3: Build a Simple Tracker
~~~python exercise id="2.3"
# Create variables to track a stock position
stock_symbol = "AAPL"
purchase_price = 150.00
current_price = 175.00
shares_owned = 10

# Calculate total gain/loss
# YOUR CODE HERE

# Print a summary
# YOUR CODE HERE
~~~

---

## The Gotchas

### Gotcha 1: `=` vs `==`

```python
x = 10    # Assignment: "x now points to 10"
x == 10   # Comparison: "does x equal 10?" (returns True/False)
```

### Gotcha 2: `is` vs `==`

~~~python runnable
a = [1, 2, 3]
b = [1, 2, 3]

print(a == b)  # True - same VALUE
print(a is b)  # False - different OBJECTS

# id() proves they're different objects
print(id(a))  # 4341234567
print(id(b))  # 4341234999 (different!)
~~~

Use `==` to compare values. Use `is` only when you care about object identity (rarely—mostly for `None`).

### Gotcha 3: Mutable Default Arguments

This is a famous Python trap:

~~~python runnable
def add_item(item, items=[]):  # Dangerous!
    items.append(item)
    return items

print(add_item("a"))  # ['a']
print(add_item("b"))  # ['a', 'b'] - Wait, what?!
~~~

The default list is created **once** when the function is defined, not each time it's called. We'll revisit this in the functions lesson.

### Gotcha 4: NoneType

`None` is Python's null value—it means "nothing" or "no value":

```python
result = None  # Explicitly set to nothing

# Common pattern
def find_stock(symbol):
    # ... search logic ...
    if not found:
        return None  # Explicitly return nothing
```

---

## Key Takeaways

1. Variables are **labels** that point to objects, not boxes that contain values
2. Multiple variables can point to the same object
3. Use `id()` to see an object's memory address
4. Use `==` to compare values, `is` to compare identity
5. Mutable objects (like lists) can surprise you when shared

---

## Next Lesson

Now that you understand how Python stores values, let's explore the different **types** of values Python can work with: **Data Types**.
