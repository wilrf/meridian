---
title: "Operators and Expressions"
phase: 1
order: 4
requires: []
prev: "1.3_data_types"
next: "1.5_control_flow"
---

# Lesson 4: Operators and Expressions

## The Problem

Data sitting in variables is useless until you *do* something with it. You need to combine values, compare them, and make calculations. Operators are the verbs of programming—they perform actions on data.

---

## The Metaphor

Operators are like tools in a workshop:

- **Arithmetic operators** (+, -, *, /) are like calculators
- **Comparison operators** (<, >, ==) are like measuring tapes that answer "bigger or smaller?"
- **Logical operators** (and, or, not) are like decision flowcharts that combine yes/no questions
- **Assignment operators** (=, +=) are like labeling machines that put names on things

An **expression** is a combination of values, variables, and operators that Python evaluates to produce a result.

---

## The Technical Reality

### Order of Operations (Precedence)

Python follows mathematical precedence, but with more operators:

```
Highest precedence (evaluated first)
    **          Exponentiation
    +x, -x, ~x  Unary plus/minus, bitwise NOT
    *, /, //, % Multiplication, division, floor div, modulo
    +, -        Addition, subtraction
    <<, >>      Bitwise shifts
    &           Bitwise AND
    ^           Bitwise XOR
    |           Bitwise OR
    ==, !=, <, <=, >, >=, is, in  Comparisons
    not         Logical NOT
    and         Logical AND
    or          Logical OR
Lowest precedence (evaluated last)
```

When in doubt, use parentheses:
~~~python runnable
# Confusing
result = 2 + 3 * 4 ** 2  # 50 (exponent first, then multiply, then add)
print(f"2 + 3 * 4 ** 2 = {result}")

# Clear
result = 2 + (3 * (4 ** 2))  # Same result, but obvious
print(f"2 + (3 * (4 ** 2)) = {result}")
~~~

### Short-Circuit Evaluation

Logical operators `and` and `or` stop evaluating as soon as the result is known:

```python
# 'and' stops at first False
False and expensive_function()  # expensive_function() never runs!

# 'or' stops at first True
True or expensive_function()    # expensive_function() never runs!
```

This is used for defensive coding:
```python
# Safe: won't divide if count is 0
if count > 0 and total / count > threshold:
    ...

# Would crash if written with 'and' evaluated left to right without short-circuit
```

---

## The Code

### Arithmetic Operators

~~~python runnable
a, b = 17, 5

print(f"a + b = {a + b}")   # 22  Addition
print(f"a - b = {a - b}")   # 12  Subtraction
print(f"a * b = {a * b}")   # 85  Multiplication
print(f"a / b = {a / b}")   # 3.4 Division (always returns float)
print(f"a // b = {a // b}") # 3   Floor division
print(f"a % b = {a % b}")   # 2   Modulo (remainder)
print(f"a ** b = {a ** b}") # 1419857  Exponentiation (17^5)

# Modulo is surprisingly useful
hour = 25
print(f"\n25 % 24 = {hour % 24}")  # 1 (wraps around!)

# Check if even/odd
number = 10
print(f"{number} % 2 == 0: {number % 2 == 0}")  # True if even

# Floor division quirk with negatives
print(f"-17 // 5 = {-17 // 5}")  # -4 (not -3! floors toward negative infinity)
~~~

### Comparison Operators

~~~python runnable
x, y = 10, 20

print(f"x == y: {x == y}")   # False  Equal
print(f"x != y: {x != y}")   # True   Not equal
print(f"x < y: {x < y}")     # True   Less than
print(f"x <= y: {x <= y}")   # True   Less than or equal
print(f"x > y: {x > y}")     # False  Greater than
print(f"x >= y: {x >= y}")   # False  Greater than or equal

# Chained comparisons (Pythonic!)
price = 150
print(f"\n100 < {price} < 200: {100 < price < 200}")

# Identity vs equality
a = [1, 2, 3]
b = [1, 2, 3]
print(f"\na == b: {a == b}")  # True (same value)
print(f"a is b: {a is b}")    # False (different objects)
~~~

### Logical Operators

~~~python runnable
# and: True only if BOTH are True
print("AND operator:")
print(f"True and True: {True and True}")
print(f"True and False: {True and False}")
print(f"False and True: {False and True}")

# or: True if EITHER is True
print("\nOR operator:")
print(f"True or False: {True or False}")
print(f"False or False: {False or False}")

# not: inverts the boolean
print("\nNOT operator:")
print(f"not True: {not True}")
print(f"not False: {not False}")

# Practical example
price = 150
volume = 1000000

is_good_buy = price < 200 and volume > 500000  # True
is_bad_buy = price > 300 or volume < 100000    # False
print(f"\nis_good_buy: {is_good_buy}")
print(f"is_bad_buy: {is_bad_buy}")
~~~

### Assignment Operators

~~~python runnable
x = 10      # Basic assignment
print(f"x = {x}")

# Compound assignment (modifies in place)
x += 5      # x = x + 5  → 15
print(f"x += 5: {x}")
x -= 3      # x = x - 3  → 12
print(f"x -= 3: {x}")
x *= 2      # x = x * 2  → 24
print(f"x *= 2: {x}")
x /= 4      # x = x / 4  → 6.0
print(f"x /= 4: {x}")

# Walrus operator := (Python 3.8+)
# Assigns AND returns the value
data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
if (n := len(data)) > 5:
    print(f"\nList has {n} items")  # Can use n here!
~~~

### Membership and Identity

~~~python runnable
# 'in' - membership test
stocks = ["AAPL", "GOOGL", "MSFT"]
print(f"'AAPL' in stocks: {'AAPL' in stocks}")
print(f"'TSLA' not in stocks: {'TSLA' not in stocks}")

# Works with strings too
print(f"'App' in 'Apple': {'App' in 'Apple'}")

# 'is' - identity test (same object in memory)
x = None
print(f"\nx is None: {x is None}")  # True (preferred way to check for None)
x = 42
print(f"x is not None: {x is not None}")
~~~

### Bitwise Operators (for ML/Finance)

~~~python runnable
# You'll encounter these in data manipulation
a = 0b1010  # 10 in binary
b = 0b1100  # 12 in binary

print(f"a & b = {a & b}")   # 8  (AND: both bits must be 1)
print(f"a | b = {a | b}")   # 14 (OR: either bit can be 1)
print(f"a ^ b = {a ^ b}")   # 6  (XOR: bits must differ)
print(f"a << 2 = {a << 2}") # 40 (left shift: multiply by 2^n)
print(f"a >> 1 = {a >> 1}") # 5 (right shift: divide by 2^n)

# Practical use: fast multiplication/division by powers of 2
x = 5
print(f"\nx << 3 = {x << 3}")  # 40 (same as x * 8)
print(f"x >> 1 = {x >> 1}")   # 2 (same as x // 2)
~~~

---

## The Exercise

### Exercise 4.1: Calculate Returns
~~~python exercise id="4.1"
# Calculate investment returns
purchase_price = 100.00
current_price = 125.00
shares = 50

# Calculate:
# 1. Total gain in dollars
# 2. Percent return
# 3. Annualized return assuming 2 years held (hint: use ** for exponents)

# YOUR CODE HERE

~~~

### Exercise 4.2: Trading Day Logic
~~~python exercise id="4.2"
# Given these conditions, determine if we should buy
price = 145.00
volume = 2500000
pe_ratio = 22.5
sector = "technology"

# Buy conditions:
# - Price under 150 AND volume over 1 million
# - OR pe_ratio under 20 (regardless of other conditions)
# - BUT NOT if sector is "energy"

# should_buy = ???  # Write the expression
# print(f"Should buy: {should_buy}")

~~~

### Exercise 4.3: Time Conversion
~~~python exercise id="4.3"
# Given total seconds, calculate hours, minutes, remaining seconds
total_seconds = 7384

# Use // and % to extract:
# hours = ???
# minutes = ???
# seconds = ???

# Should print: 2 hours, 3 minutes, 4 seconds

~~~

### Exercise 4.4: Short-Circuit Practice
Predict the output WITHOUT running, then run to verify:
~~~python exercise id="4.4"
def side_effect():
    print("Function was called!")
    return True

# What prints for each?
print("result1 = False and side_effect()")
result1 = False and side_effect()

print("\nresult2 = True and side_effect()")
result2 = True and side_effect()

print("\nresult3 = True or side_effect()")
result3 = True or side_effect()

print("\nresult4 = False or side_effect()")
result4 = False or side_effect()
~~~

---

## The Gotchas

### Gotcha 1: Division Always Returns Float

~~~python runnable
print(f"10 / 2 = {10 / 2}")  # 5.0 (not 5!)
print(f"type(10 / 2): {type(10 / 2)}")

# Use // if you need an integer
print(f"\n10 // 2 = {10 // 2}")  # 5
print(f"type(10 // 2): {type(10 // 2)}")
~~~

### Gotcha 2: Chained Assignment Gotcha

~~~python runnable
# This works differently than you might think
a = b = []  # BOTH point to the SAME list!
a.append(1)
print(f"b = {b}")  # [1] - b changed too!

# If you want separate lists:
a = []
b = []
a.append(2)
print(f"Now b = {b}")  # [] - b is separate
~~~

### Gotcha 3: `not in` vs `not ... in`

```python
# Correct
if item not in collection:
    pass

# Confusing (but valid)
if not item in collection:  # Same result, but harder to read
    pass
```

Always use `not in` as a single operator.

### Gotcha 4: Comparing Floats

~~~python runnable
print(f"0.1 + 0.2 == 0.3: {0.1 + 0.2 == 0.3}")  # False! (floating point precision)
print(f"0.1 + 0.2 = {0.1 + 0.2}")

# Instead, check if "close enough"
import math
print(f"\nmath.isclose(0.1 + 0.2, 0.3): {math.isclose(0.1 + 0.2, 0.3)}")

# Or use a tolerance
print(f"abs((0.1 + 0.2) - 0.3) < 0.0001: {abs((0.1 + 0.2) - 0.3) < 0.0001}")
~~~

### Gotcha 5: `and`/`or` Return Values, Not Booleans

~~~python runnable
# 'and' returns the first falsy value, or the last value
print(f"0 and 5 = {0 and 5}")      # 0 (first falsy)
print(f"3 and 5 = {3 and 5}")      # 5 (last value, both truthy)

# 'or' returns the first truthy value, or the last value
print(f"\n0 or 5 = {0 or 5}")       # 5 (first truthy)
print(f'0 or "" = {repr(0 or "")}')  # "" (last value, both falsy)
print(f"3 or 5 = {3 or 5}")       # 3 (first truthy)

# This enables idioms like:
user_input = ""  # Simulate empty input
name = user_input or "default"  # Use default if input is empty
print(f"\nname = {name}")
~~~

---

## Key Takeaways

1. Operators have precedence—use parentheses when unclear
2. `and`/`or` short-circuit and return actual values, not just booleans
3. Division `/` always returns float; use `//` for integer division
4. `%` (modulo) is surprisingly useful for wrapping, cycling, and even/odd checks
5. Use `is` for None checks, `==` for value comparisons
6. Chained comparisons (`a < b < c`) are Pythonic

---

## Next Lesson

Now that you can perform calculations and comparisons, let's learn how to make decisions based on them: **Control Flow (if/else)**.
