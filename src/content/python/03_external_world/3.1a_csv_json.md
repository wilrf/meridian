---
title: "CSV and JSON"
phase: 3
order: 1.5
requires: []
prev: "3.1_files"
next: "3.2_apis"
---

# Lesson: Working with CSV and JSON

## The Problem

Plain text files are fine for simple data, but real-world data has **structure**. Stock prices have symbols, dates, and values. API responses have nested objects. Configuration files have key-value pairs. You need standard formats for structured data that both humans and programs can understand.

---

## The Metaphor

Think of data formats like **packaging for shipping**:

- **CSV** (Comma-Separated Values) is like a **spreadsheet**—rows and columns, perfect for tabular data like price histories
- **JSON** (JavaScript Object Notation) is like **nested boxes**—can contain objects within objects, perfect for complex structures like API responses

Both are **plain text**, so you can open them in any editor, but they follow specific rules that make them machine-readable.

---

## The Technical Reality

### CSV Structure

```
symbol,date,open,high,low,close,volume
AAPL,2024-01-15,175.50,178.30,174.20,177.80,52000000
AAPL,2024-01-16,177.80,179.50,176.90,178.20,48000000
```

- First row is typically headers
- Each row is a record
- Fields separated by commas (or other delimiters)
- Simple but limited—no nested data, all values are strings

### JSON Structure

```json
{
    "symbol": "AAPL",
    "name": "Apple Inc.",
    "price": 175.50,
    "change": 2.30,
    "metrics": {
        "pe_ratio": 28.5,
        "market_cap": 2800000000000
    },
    "tags": ["technology", "consumer", "mega-cap"]
}
```

- Supports nested objects and arrays
- Preserves data types (numbers, strings, booleans, null)
- More flexible but more complex
- Standard for API responses

---

## The Code: CSV

### Reading CSV Files

~~~python runnable
import csv

# Sample CSV data (normally you'd read from a file)
csv_data = """symbol,date,close,volume
AAPL,2024-01-15,177.80,52000000
AAPL,2024-01-16,178.20,48000000
GOOGL,2024-01-15,140.25,28000000
GOOGL,2024-01-16,141.50,31000000"""

# Using csv.reader (returns lists)
import io
reader = csv.reader(io.StringIO(csv_data))
header = next(reader)  # Get header row
print(f"Headers: {header}")

for row in reader:
    symbol, date, close, volume = row
    print(f"{symbol} on {date}: ${close} ({volume} shares)")
~~~

~~~python runnable
import csv
import io

csv_data = """symbol,date,close,volume
AAPL,2024-01-15,177.80,52000000
AAPL,2024-01-16,178.20,48000000
GOOGL,2024-01-15,140.25,28000000"""

# Using csv.DictReader (returns dictionaries - usually better!)
reader = csv.DictReader(io.StringIO(csv_data))
for row in reader:
    print(f"{row['symbol']}: ${row['close']}")

# Access by column name - much clearer!
~~~

### Writing CSV Files

~~~python runnable
import csv
import io

# Data to write
stocks = [
    {"symbol": "AAPL", "price": 175.50, "shares": 100},
    {"symbol": "GOOGL", "price": 140.25, "shares": 50},
    {"symbol": "MSFT", "price": 380.00, "shares": 25},
]

# Write to string (normally you'd write to a file)
output = io.StringIO()
fieldnames = ["symbol", "price", "shares", "total_value"]

writer = csv.DictWriter(output, fieldnames=fieldnames)
writer.writeheader()

for stock in stocks:
    stock["total_value"] = stock["price"] * stock["shares"]
    writer.writerow(stock)

print(output.getvalue())
~~~

### CSV Options and Edge Cases

~~~python runnable
import csv
import io

# Handling quoted fields with commas inside
data_with_commas = '''symbol,name,price
AAPL,"Apple, Inc.",175.50
JPM,"JPMorgan Chase & Co.",180.25'''

reader = csv.DictReader(io.StringIO(data_with_commas))
for row in reader:
    print(f"{row['symbol']}: {row['name']} - ${row['price']}")

# Using different delimiters (TSV - tab-separated)
tsv_data = "symbol\tprice\tvolume\nAAPL\t175.50\t52000000"
reader = csv.reader(io.StringIO(tsv_data), delimiter='\t')
for row in reader:
    print(row)

# Handling missing values
data_with_blanks = '''symbol,price,dividend
AAPL,175.50,0.96
GOOGL,140.25,'''

reader = csv.DictReader(io.StringIO(data_with_blanks))
for row in reader:
    dividend = float(row['dividend']) if row['dividend'] else 0.0
    print(f"{row['symbol']}: dividend = {dividend}")
~~~

---

## The Code: JSON

### Reading JSON

~~~python runnable
import json

# JSON string (normally from a file or API)
json_string = '''
{
    "portfolio": {
        "name": "Growth Portfolio",
        "holdings": [
            {"symbol": "AAPL", "shares": 100, "avgCost": 150.00},
            {"symbol": "GOOGL", "shares": 50, "avgCost": 120.00}
        ],
        "cash": 5000.00
    }
}
'''

# Parse JSON string to Python objects
data = json.loads(json_string)

# Now it's regular Python dicts and lists!
print(f"Portfolio: {data['portfolio']['name']}")
print(f"Cash: ${data['portfolio']['cash']:.2f}")

for holding in data['portfolio']['holdings']:
    print(f"  {holding['symbol']}: {holding['shares']} shares @ ${holding['avgCost']:.2f}")
~~~

### Writing JSON

~~~python runnable
import json

# Python objects
portfolio = {
    "name": "Tech Portfolio",
    "holdings": [
        {"symbol": "AAPL", "shares": 100, "price": 175.50},
        {"symbol": "MSFT", "shares": 50, "price": 380.00},
    ],
    "last_updated": "2024-01-15T10:30:00Z",
    "total_value": None,  # Will be calculated
}

# Calculate total
total = sum(h["shares"] * h["price"] for h in portfolio["holdings"])
portfolio["total_value"] = total

# Convert to JSON string
json_output = json.dumps(portfolio)
print("Compact JSON:")
print(json_output)

# Pretty print with indentation
json_pretty = json.dumps(portfolio, indent=2)
print("\nPretty JSON:")
print(json_pretty)

# Sort keys alphabetically
json_sorted = json.dumps(portfolio, indent=2, sort_keys=True)
print("\nSorted keys:")
print(json_sorted)
~~~

### Working with JSON Files

~~~python runnable
import json
import io

# Simulating file operations with StringIO

# Writing JSON to a "file"
data = {"stocks": ["AAPL", "GOOGL", "MSFT"], "count": 3}
file = io.StringIO()
json.dump(data, file, indent=2)

# Reading JSON from a "file"
file.seek(0)  # Go back to beginning
loaded_data = json.load(file)
print(f"Loaded: {loaded_data}")

# In real code:
# with open("portfolio.json", "w") as f:
#     json.dump(data, f, indent=2)
#
# with open("portfolio.json") as f:
#     data = json.load(f)
~~~

### JSON Data Types

~~~python runnable
import json

# JSON types map to Python types:
# - object → dict
# - array → list
# - string → str
# - number → int or float
# - true/false → True/False
# - null → None

data = {
    "string": "hello",
    "integer": 42,
    "float": 3.14,
    "boolean": True,
    "null_value": None,
    "array": [1, 2, 3],
    "nested": {"a": 1, "b": 2}
}

json_str = json.dumps(data, indent=2)
print(json_str)

# Parse back
parsed = json.loads(json_str)
print(f"\nPython types:")
for key, value in parsed.items():
    print(f"  {key}: {value!r} ({type(value).__name__})")
~~~

### Handling JSON Edge Cases

~~~python runnable
import json
from datetime import datetime, date
from decimal import Decimal

# Problem: Some Python types aren't JSON serializable
data = {
    "date": datetime.now(),
    "price": Decimal("175.50"),
}

# This fails:
# json.dumps(data)  # TypeError: Object of type datetime is not JSON serializable

# Solution 1: Custom encoder
class CustomEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, datetime):
            return obj.isoformat()
        if isinstance(obj, date):
            return obj.strftime("%Y-%m-%d")
        if isinstance(obj, Decimal):
            return float(obj)
        return super().default(obj)

json_str = json.dumps(data, cls=CustomEncoder, indent=2)
print("With custom encoder:")
print(json_str)

# Solution 2: Convert before encoding
data_converted = {
    "date": datetime.now().isoformat(),
    "price": float(Decimal("175.50")),
}
print("\nPre-converted:")
print(json.dumps(data_converted, indent=2))
~~~

---

## Comparing CSV and JSON

| Feature | CSV | JSON |
|---------|-----|------|
| Structure | Flat (rows/columns) | Nested (objects/arrays) |
| Data types | All strings | Preserves types |
| Human readable | Very easy | Easy |
| File size | Smaller | Larger |
| Best for | Tabular data, spreadsheets | API data, configs |
| Schema | Header row (informal) | None (flexible) |

~~~python runnable
# Same data in both formats

# CSV - great for tabular data
csv_data = """symbol,price,shares,value
AAPL,175.50,100,17550.00
GOOGL,140.25,50,7012.50
MSFT,380.00,25,9500.00"""

# JSON - great for nested/complex data
json_data = {
    "portfolio": {
        "name": "My Portfolio",
        "holdings": [
            {"symbol": "AAPL", "price": 175.50, "shares": 100},
            {"symbol": "GOOGL", "price": 140.25, "shares": 50},
            {"symbol": "MSFT", "price": 380.00, "shares": 25}
        ],
        "metadata": {
            "created": "2024-01-15",
            "currency": "USD"
        }
    }
}

print("CSV is simpler for flat data")
print("JSON is better for structured/nested data")
~~~

---

## The Exercise

### Exercise: Parse Stock Data CSV
~~~python exercise id="3.1a.1"
import csv
import io

csv_data = """date,symbol,open,high,low,close,volume
2024-01-15,AAPL,175.50,178.30,174.20,177.80,52000000
2024-01-15,GOOGL,138.00,141.50,137.50,140.25,28000000
2024-01-16,AAPL,177.80,179.50,176.90,178.20,48000000
2024-01-16,GOOGL,140.25,143.00,139.80,141.50,31000000
2024-01-17,AAPL,178.20,180.00,177.50,179.80,55000000
2024-01-17,GOOGL,141.50,142.80,140.00,142.00,29000000"""

def analyze_stock_data(csv_string: str) -> dict:
    """
    Parse CSV and return analysis for each stock:
    {
        "AAPL": {
            "avg_close": ...,
            "max_high": ...,
            "min_low": ...,
            "total_volume": ...,
            "price_change": ...  # (last close - first close)
        },
        "GOOGL": {...}
    }
    """
    # YOUR CODE HERE
    pass

result = analyze_stock_data(csv_data)
for symbol, stats in result.items():
    print(f"\n{symbol}:")
    for key, value in stats.items():
        print(f"  {key}: {value}")
~~~

### Exercise: Portfolio JSON Manager
~~~python exercise id="3.1a.2"
import json

def load_portfolio(json_string: str) -> dict:
    """Load portfolio from JSON string."""
    return json.loads(json_string)

def calculate_portfolio_value(portfolio: dict, prices: dict) -> float:
    """
    Calculate total portfolio value given current prices.

    portfolio: {"holdings": [{"symbol": "AAPL", "shares": 100}, ...], "cash": 5000}
    prices: {"AAPL": 175.50, "GOOGL": 140.25}
    """
    # YOUR CODE HERE
    pass

def add_holding(portfolio: dict, symbol: str, shares: int, price: float) -> dict:
    """
    Add a new holding or increase existing holding.
    Deduct cost from cash. Raise ValueError if insufficient cash.
    Return updated portfolio.
    """
    # YOUR CODE HERE
    pass

def save_portfolio(portfolio: dict) -> str:
    """Save portfolio to pretty-printed JSON string."""
    return json.dumps(portfolio, indent=2)

# Test
portfolio_json = '''
{
    "name": "Test Portfolio",
    "holdings": [
        {"symbol": "AAPL", "shares": 100, "avg_cost": 150.00},
        {"symbol": "GOOGL", "shares": 50, "avg_cost": 120.00}
    ],
    "cash": 10000.00
}
'''

portfolio = load_portfolio(portfolio_json)
prices = {"AAPL": 175.50, "GOOGL": 140.25, "MSFT": 380.00}

print(f"Portfolio value: ${calculate_portfolio_value(portfolio, prices):.2f}")

portfolio = add_holding(portfolio, "MSFT", 10, 380.00)
print(f"\nAfter adding MSFT:")
print(save_portfolio(portfolio))
~~~

### Exercise: CSV to JSON Converter
~~~python exercise id="3.1a.3"
import csv
import json
import io

def csv_to_json(csv_string: str, group_by: str = None) -> str:
    """
    Convert CSV to JSON.

    If group_by is None, return a list of objects:
    [{"symbol": "AAPL", "price": "175.50"}, ...]

    If group_by is a column name, group by that column:
    {"AAPL": [{"date": "2024-01-15", "price": "175.50"}, ...], ...}
    """
    # YOUR CODE HERE
    pass

csv_data = """symbol,date,price
AAPL,2024-01-15,175.50
AAPL,2024-01-16,178.20
GOOGL,2024-01-15,140.25
GOOGL,2024-01-16,141.50"""

print("Without grouping:")
print(csv_to_json(csv_data))

print("\nGrouped by symbol:")
print(csv_to_json(csv_data, group_by="symbol"))
~~~

### Exercise: Config File Manager
~~~python exercise id="3.1a.4"
import json

class ConfigManager:
    """
    Manage application configuration stored in JSON.

    Features:
    - Load config with defaults
    - Get nested values with dot notation: config.get("api.timeout")
    - Set values: config.set("api.timeout", 30)
    - Save config
    """

    def __init__(self, defaults: dict = None):
        self.data = defaults.copy() if defaults else {}

    def load(self, json_string: str):
        """Load config from JSON, merging with defaults."""
        # YOUR CODE HERE
        pass

    def get(self, key: str, default=None):
        """
        Get value using dot notation.
        "api.timeout" returns self.data["api"]["timeout"]
        """
        # YOUR CODE HERE
        pass

    def set(self, key: str, value):
        """
        Set value using dot notation.
        Creates nested dicts as needed.
        """
        # YOUR CODE HERE
        pass

    def save(self) -> str:
        """Save config to JSON string."""
        return json.dumps(self.data, indent=2)


# Test
defaults = {
    "api": {
        "timeout": 30,
        "retries": 3
    },
    "logging": {
        "level": "INFO"
    }
}

config = ConfigManager(defaults)
config.load('{"api": {"timeout": 60}, "feature_flags": {"new_ui": true}}')

print(f"API timeout: {config.get('api.timeout')}")  # 60 (from loaded)
print(f"API retries: {config.get('api.retries')}")  # 3 (from defaults)
print(f"New UI: {config.get('feature_flags.new_ui')}")  # True

config.set("api.base_url", "https://api.example.com")
print(f"\nUpdated config:")
print(config.save())
~~~

---

## The Gotchas

### Gotcha 1: CSV Values Are Always Strings

~~~python runnable
import csv
import io

csv_data = "name,price,quantity\nApple,175.50,100"

reader = csv.DictReader(io.StringIO(csv_data))
for row in reader:
    # Everything is a string!
    print(f"price type: {type(row['price'])}")  # <class 'str'>

    # Must convert explicitly
    price = float(row['price'])
    quantity = int(row['quantity'])
    print(f"Total: ${price * quantity:.2f}")
~~~

### Gotcha 2: JSON Keys Must Be Strings

~~~python runnable
import json

# Python allows any hashable key
python_dict = {1: "one", (1, 2): "tuple_key"}

# JSON only allows string keys
try:
    json.dumps(python_dict)
except TypeError as e:
    print(f"Error: {e}")

# Keys get converted to strings
data = {1: "one", 2: "two"}
json_str = json.dumps(data)
print(json_str)  # '{"1": "one", "2": "two"}'

# And stay as strings when parsed back!
parsed = json.loads(json_str)
print(parsed)  # {'1': 'one', '2': 'two'} - string keys now!
~~~

### Gotcha 3: Newlines in CSV Fields

~~~python runnable
import csv
import io

# Fields with newlines need quotes
data = [
    {"name": "Note 1", "content": "Line 1\nLine 2"},
    {"name": "Note 2", "content": "Simple content"},
]

output = io.StringIO()
writer = csv.DictWriter(output, fieldnames=["name", "content"])
writer.writeheader()
writer.writerows(data)

print(output.getvalue())
# Note the quoted field with the newline
~~~

### Gotcha 4: JSON Trailing Commas

~~~python runnable
import json

# Invalid JSON - trailing comma
bad_json = '{"a": 1, "b": 2,}'  # Note trailing comma

try:
    json.loads(bad_json)
except json.JSONDecodeError as e:
    print(f"Error: {e}")

# Valid JSON - no trailing comma
good_json = '{"a": 1, "b": 2}'
print(json.loads(good_json))
~~~

### Gotcha 5: Large Numbers in JSON

~~~python runnable
import json

# Large integers lose precision in some JSON parsers (JavaScript issue)
data = {"big_number": 9999999999999999999}
json_str = json.dumps(data)
print(json_str)

# For financial data, consider using strings for large/precise numbers
data_safe = {"big_number": "9999999999999999999"}
print(json.dumps(data_safe))
~~~

---

## Real World Application: Stock Data Pipeline

~~~python runnable
import csv
import json
import io
from datetime import datetime

# Simulated: Load stock prices from CSV
csv_prices = """date,symbol,close,volume
2024-01-15,AAPL,177.80,52000000
2024-01-16,AAPL,178.20,48000000
2024-01-17,AAPL,179.80,55000000"""

# Simulated: Load portfolio from JSON
json_portfolio = '''{
    "holdings": [
        {"symbol": "AAPL", "shares": 100, "avg_cost": 150.00}
    ],
    "cash": 5000.00
}'''

# Step 1: Parse CSV price data
prices_by_date = {}
reader = csv.DictReader(io.StringIO(csv_prices))
for row in reader:
    date = row['date']
    if date not in prices_by_date:
        prices_by_date[date] = {}
    prices_by_date[date][row['symbol']] = {
        'close': float(row['close']),
        'volume': int(row['volume'])
    }

# Step 2: Parse JSON portfolio
portfolio = json.loads(json_portfolio)

# Step 3: Calculate portfolio value over time
print("Portfolio Value Over Time")
print("=" * 40)

for date in sorted(prices_by_date.keys()):
    prices = prices_by_date[date]
    total_value = portfolio['cash']

    for holding in portfolio['holdings']:
        symbol = holding['symbol']
        if symbol in prices:
            value = holding['shares'] * prices[symbol]['close']
            total_value += value

    print(f"{date}: ${total_value:,.2f}")

# Step 4: Generate JSON report
latest_date = max(prices_by_date.keys())
latest_prices = prices_by_date[latest_date]

report = {
    "report_date": latest_date,
    "generated_at": datetime.now().isoformat(),
    "portfolio_value": total_value,
    "holdings_detail": []
}

for holding in portfolio['holdings']:
    symbol = holding['symbol']
    current_price = latest_prices.get(symbol, {}).get('close', 0)
    value = holding['shares'] * current_price
    gain = (current_price - holding['avg_cost']) * holding['shares']

    report["holdings_detail"].append({
        "symbol": symbol,
        "shares": holding['shares'],
        "current_price": current_price,
        "value": value,
        "unrealized_gain": gain
    })

print("\nJSON Report:")
print(json.dumps(report, indent=2))
~~~

---

## Key Takeaways

1. **CSV** is best for flat, tabular data (spreadsheet-like)
2. **JSON** is best for nested, structured data (API responses, configs)
3. Use `csv.DictReader`/`DictWriter` for readable CSV code
4. Use `json.loads()`/`json.dumps()` for strings, `json.load()`/`json.dump()` for files
5. CSV values are always strings—convert explicitly
6. JSON preserves data types but keys must be strings
7. For financial data, consider `Decimal` and careful type handling

---

## Next Lesson

Now you can read and write structured data files. Let's learn to fetch data from the internet: **HTTP and APIs**.
