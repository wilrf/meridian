---
title: "Modules and Imports"
phase: 3
order: 1
requires: []
prev: "2.5_classes"
next: "3.2_virtual_environments"
---

# Lesson 1: Modules and Imports

> **Note:** In this web platform, you can import modules from the standard library. Creating your own multi-file modules is simulated in the exercises.

## The Problem

So far, you've written all your code in a single file. This works for small scripts, but imagine building a trading system with 10,000 lines of code. Scrolling through one giant file would be a nightmare. You need a way to **organize** your code into smaller, manageable pieces.

---

## The Metaphor

Think of your code like a **book**.

- **One giant file** is like a book written on a single, continuous scroll. To find a specific topic, you have to unroll the whole thing.
- **Modules** are like **chapters**. You split the content into logical sections (Chapter 1: Intro, Chapter 2: Plot).
- **Imports** are like the **Table of Contents**. They tell you where to find specific information ("See Chapter 3 for details").

By splitting code into modules (files), you can focus on one piece at a time.

---

## The Technical Reality

In Python, **every `.py` file is a module**. The file name is the module name.

When you say `import math`, Python:
1.  Looks for a file named `math.py` (or a built-in module).
2.  Runs that file from top to bottom.
3.  Makes the names defined in that file available to you.

### The `sys.path` List
Python doesn't look everywhere on your computer. It only looks in specific folders listed in `sys.path`:
1.  The directory of the current script.
2.  Standard library directories (where Python is installed).
3.  Site-packages (where you install 3rd party libraries).

---

## The Code

### Creating a Module

Create a file named `financial_utils.py`:

~~~python runnable
# financial_utils.py
TAX_RATE = 0.15

def calculate_tax(profit):
    """Calculate tax on profit."""
    if profit < 0:
        return 0
    return profit * TAX_RATE

def to_usd(amount):
    """Format number as USD."""
    return f"${amount:,.2f}"
~~~

### Importing the Module

Now, in your main script (e.g., `main.py` in the same folder):

~~~python runnable
# main.py
import financial_utils

profit = 1000
tax = financial_utils.calculate_tax(profit)
print(f"Profit: {financial_utils.to_usd(profit)}")
print(f"Tax: {financial_utils.to_usd(tax)}")
~~~

### Different Ways to Import

~~~python runnable
# 1. Import the whole module (Best for clarity)
import financial_utils
financial_utils.calculate_tax(100)

# 2. Import specific names (Convenient)
from financial_utils import calculate_tax, to_usd
calculate_tax(100)

# 3. Import with alias (Good for long names)
import financial_utils as fin
fin.calculate_tax(100)

# 4. Import everything (AVOID THIS!)
from financial_utils import *
# Why avoid? If financial_utils has a variable named 'print',
# you just overwrote Python's print function!
~~~

### Packages (Folders)

A **package** is just a folder containing modules. To make Python treat a folder as a package, it used to require an `__init__.py` file (and still often does for compatibility).

Structure:
```
my_project/
    main.py
    analysis/
        __init__.py
        stats.py
        charts.py
```

Usage:
```python
# main.py
from analysis import stats
mean = stats.calculate_mean([1, 2, 3])
```

---

## The Exercise

### Exercise 3.1: Split the Logic

You have a messy script. Split it into a module and a main script.

1.  Create `shapes.py` with these functions:
    - `area_circle(radius)`
    - `area_rectangle(width, height)`
    - `PI = 3.14159`
2.  Create `main.py` that imports them and calculates the area of a circle with radius 5.

~~~python exercise id="3.1"
# This is the content for shapes.py
# (Write the functions here)

# This is the content for main.py
# (Import and use them here)
~~~

---

## The Gotchas

### Gotcha 1: Circular Imports
File A imports File B, and File B imports File A. Python gets stuck in a loop.
*Fix*: Move the shared logic to a third File C, and have both A and B import C.

### Gotcha 2: Name Collisions
```python
from math import pow
from my_utils import pow  # Oops, you just overwrote math.pow!
```
*Fix*: Use `import math` and `import my_utils`, then call `math.pow()` and `my_utils.pow()`.

### Gotcha 3: Running vs Importing
Sometimes you want code to run ONLY when you execute the file, not when you import it.

```python
# my_module.py
def do_something():
    print("Doing it!")

# This runs immediately when imported!
do_something()
```

*Fix*: Use the `if __name__ == "__main__":` block.

```python
# my_module.py
def do_something():
    print("Doing it!")

if __name__ == "__main__":
    # This only runs if you run 'python my_module.py'
    # It is SKIPPED if you do 'import my_module'
    do_something()
```

---

## Key Takeaways

1.  **Modules** are just `.py` files.
2.  **Packages** are folders containing modules.
3.  Use `import` to use code from other files.
4.  Avoid `from module import *` to prevent naming conflicts.
5.  Use `if __name__ == "__main__":` to control execution.

---

## Next Lesson

Now that you can organize your own code, let's look at how to manage code written by others: **Virtual Environments**.
