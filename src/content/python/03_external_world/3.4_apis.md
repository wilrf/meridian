---
title: "APIs"
phase: 3
order: 2
requires: ["requests"]
prev: "3.3_files"
next: "3.5_debugging"
---

# Lesson 5: HTTP and APIs

## The Problem

Your program needs real-time stock prices, not hardcoded data. The prices live on a server somewhere on the internet. You need a way to request data from remote servers and process their responses.

---

## The Metaphor

An API (Application Programming Interface) is like a **restaurant waiter**:

- You (the client) sit at a table (your program)
- You give your **order** to the waiter (HTTP request)
- The waiter takes it to the kitchen (server)
- The kitchen prepares your food (processes the request)
- The waiter brings back your meal (HTTP response)

You don't go into the kitchen—you interact through a defined interface (the waiter/menu). The kitchen's internal workings are hidden from you.

---

## The Technical Reality

### HTTP Basics

HTTP (HyperText Transfer Protocol) is how the web communicates:

```
Client                          Server
  |                               |
  |------- HTTP Request --------> |
  |   GET /api/stocks/AAPL        |
  |   Host: api.example.com       |
  |                               |
  | <----- HTTP Response -------- |
  |   200 OK                      |
  |   {"symbol": "AAPL", ...}     |
```

**Request** components:
- **Method**: GET (read), POST (create), PUT (update), DELETE (remove)
- **URL**: Where to send the request
- **Headers**: Metadata (authentication, content type)
- **Body**: Data being sent (for POST/PUT)

**Response** components:
- **Status code**: 200 (OK), 404 (Not Found), 500 (Server Error)
- **Headers**: Metadata about the response
- **Body**: The actual data (often JSON)

### REST APIs

Most modern APIs follow REST (Representational State Transfer) conventions:

```
GET    /stocks         → List all stocks
GET    /stocks/AAPL    → Get specific stock
POST   /stocks         → Create new stock
PUT    /stocks/AAPL    → Update stock
DELETE /stocks/AAPL    → Delete stock
```

---

## The Code

### Installing requests

```bash
pip install requests
```

### Basic GET Request

~~~python runnable
import requests

# Simple GET request
response = requests.get("https://api.example.com/stocks/AAPL")

# Check status
print(response.status_code)  # 200
print(response.ok)           # True (status < 400)

# Get response body
print(response.text)         # Raw text
print(response.json())       # Parse as JSON → dict
~~~

### Real Example: Free Stock API

~~~python runnable
import requests

def get_stock_quote(symbol: str) -> dict:
    """
    Get stock quote from Alpha Vantage API.
    Free tier: 25 requests/day. Get key at alphavantage.co
    """
    API_KEY = "YOUR_API_KEY"  # Get free key from alphavantage.co
    url = "https://www.alphavantage.co/query"

    params = {
        "function": "GLOBAL_QUOTE",
        "symbol": symbol,
        "apikey": API_KEY
    }

    response = requests.get(url, params=params)
    response.raise_for_status()  # Raises exception for 4xx/5xx

    data = response.json()
    quote = data.get("Global Quote", {})

    return {
        "symbol": quote.get("01. symbol"),
        "price": float(quote.get("05. price", 0)),
        "change": float(quote.get("09. change", 0)),
        "change_percent": quote.get("10. change percent", "0%"),
    }

# Usage
# quote = get_stock_quote("AAPL")
# print(f"AAPL: ${quote['price']} ({quote['change_percent']})")
~~~

### Request Parameters and Headers

~~~python runnable
# Query parameters (added to URL)
params = {"symbol": "AAPL", "period": "1d"}
response = requests.get("https://api.example.com/prices", params=params)
# Actually requests: https://api.example.com/prices?symbol=AAPL&period=1d

# Headers (for authentication, content type, etc.)
headers = {
    "Authorization": "Bearer YOUR_API_TOKEN",
    "Content-Type": "application/json"
}
response = requests.get(url, headers=headers)
~~~

### POST Requests (Sending Data)

~~~python runnable
import requests

# Send JSON data
data = {
    "symbol": "AAPL",
    "shares": 100,
    "action": "buy"
}

response = requests.post(
    "https://api.example.com/orders",
    json=data,  # Automatically sets Content-Type header
    headers={"Authorization": "Bearer TOKEN"}
)

# Check response
if response.ok:
    order = response.json()
    print(f"Order created: {order['id']}")
else:
    print(f"Error: {response.status_code} - {response.text}")
~~~

### Error Handling

~~~python runnable
import requests
from requests.exceptions import RequestException, Timeout, HTTPError

def fetch_with_retry(url, max_retries=3, timeout=10):
    """Fetch URL with retry logic."""
    for attempt in range(max_retries):
        try:
            response = requests.get(url, timeout=timeout)
            response.raise_for_status()  # Raises HTTPError for 4xx/5xx
            return response.json()

        except Timeout:
            print(f"Attempt {attempt + 1}: Timeout")
        except HTTPError as e:
            print(f"HTTP Error: {e.response.status_code}")
            if e.response.status_code == 404:
                return None  # Not found - don't retry
            if e.response.status_code >= 500:
                continue  # Server error - retry
            raise  # Client error - don't retry
        except RequestException as e:
            print(f"Request failed: {e}")

    raise Exception(f"Failed after {max_retries} attempts")
~~~

### Sessions (For Multiple Requests)

~~~python runnable
# Sessions reuse connections and persist settings
with requests.Session() as session:
    session.headers.update({"Authorization": "Bearer TOKEN"})

    # All requests use the session's headers
    r1 = session.get("https://api.example.com/portfolio")
    r2 = session.get("https://api.example.com/orders")
    r3 = session.post("https://api.example.com/orders", json=data)
~~~

### Rate Limiting

~~~python runnable
import time
import requests

class RateLimitedClient:
    """Client that respects API rate limits."""

    def __init__(self, base_url, requests_per_minute=60):
        self.base_url = base_url
        self.min_interval = 60 / requests_per_minute
        self.last_request = 0

    def get(self, endpoint, **kwargs):
        # Wait if needed
        elapsed = time.time() - self.last_request
        if elapsed < self.min_interval:
            time.sleep(self.min_interval - elapsed)

        self.last_request = time.time()
        return requests.get(f"{self.base_url}{endpoint}", **kwargs)


# Usage
client = RateLimitedClient("https://api.example.com", requests_per_minute=30)
for symbol in ["AAPL", "GOOGL", "MSFT"]:
    response = client.get(f"/stocks/{symbol}")
    # Automatically waits 2 seconds between requests
~~~

---

## The Exercise

### Exercise 5.1: Weather API
~~~python exercise id="3.2.1"
# Use a free weather API (like wttr.in) to get weather data
# wttr.in doesn't require authentication!

def get_weather(city: str) -> dict:
    """
    Get weather for a city.
    API: https://wttr.in/{city}?format=j1

    Return dict with: temperature, conditions, humidity
    """
    pass

# Test:
# weather = get_weather("London")
# print(f"London: {weather['temperature']}°C, {weather['conditions']}")
~~~

### Exercise 5.2: Cryptocurrency Prices
~~~python exercise id="3.2.2"
# Use CoinGecko API (free, no auth required)
# https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd

def get_crypto_prices(coins: list[str]) -> dict[str, float]:
    """
    Get USD prices for cryptocurrencies.

    Parameters
    ----------
    coins : list of str
        Coin IDs (e.g., ["bitcoin", "ethereum"])

    Returns
    -------
    dict mapping coin name to USD price
    """
    pass

# Test:
# prices = get_crypto_prices(["bitcoin", "ethereum", "dogecoin"])
~~~

### Exercise 5.3: Build a Stock Monitor
~~~python exercise id="3.2.3"
class StockMonitor:
    """
    Monitor stock prices with alerts.

    Features:
    - Fetch current prices
    - Set price alerts (above/below threshold)
    - Check alerts and notify
    """

    def __init__(self, api_key: str):
        pass

    def add_alert(self, symbol: str, threshold: float, direction: str):
        """Add price alert. direction: 'above' or 'below'"""
        pass

    def check_alerts(self) -> list[str]:
        """Check all alerts, return triggered messages."""
        pass
~~~

---

## The Gotchas

### Gotcha 1: Not Checking Status Codes

```python
# BAD - assumes success
response = requests.get(url)
data = response.json()  # Crashes if 404/500!

# GOOD - check first
response = requests.get(url)
if response.ok:
    data = response.json()
else:
    print(f"Error: {response.status_code}")

# BETTER - raise exception
response = requests.get(url)
response.raise_for_status()  # Raises HTTPError for 4xx/5xx
data = response.json()
```

### Gotcha 2: No Timeout

```python
# BAD - can hang forever
response = requests.get(url)

# GOOD - always set timeout
response = requests.get(url, timeout=10)  # 10 seconds
```

### Gotcha 3: Exposing API Keys

```python
# BAD - hardcoded key
API_KEY = "sk-abc123secret"

# GOOD - environment variable or config
import os
API_KEY = os.environ.get("API_KEY")

# For this learning environment, you can define keys directly:
API_KEY = "your-api-key-here"  # Replace with your actual key
```

### Gotcha 4: Not Handling Rate Limits

```python
# API returns 429 Too Many Requests
response = requests.get(url)
if response.status_code == 429:
    retry_after = int(response.headers.get("Retry-After", 60))
    print(f"Rate limited. Waiting {retry_after} seconds...")
    time.sleep(retry_after)
    # Retry the request
```

---

## Key Takeaways

1. Use the `requests` library for HTTP calls
2. Always check `response.ok` or use `raise_for_status()`
3. Always set a timeout on requests
4. Store API keys in environment variables, never in code
5. Respect rate limits—add delays between requests
6. Use sessions for multiple requests to the same API
7. Handle errors gracefully with retries for transient failures

---

## Next Lesson

You can now fetch data from anywhere on the internet. Time to combine everything into a real project: **Project: Stock Price Fetcher**.
