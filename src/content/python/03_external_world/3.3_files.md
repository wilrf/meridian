---
title: "Files"
phase: 3
order: 1
requires: []
prev: "3.2_virtual_environments"
next: "3.4_apis"
---

# Lesson 3: Working with Files

## The Problem

Your programs lose all their data when they stop running. Variables disappear, calculations vanish. You need to **persist data**—save it to disk so it survives between runs, and load it back when needed.

---

## The Metaphor

Think of files like **notebooks**:
- You **open** a notebook (file) to read or write
- You work with it (read pages, write new content)
- You **close** it when done (saves your work, frees the resource)
- Notebooks stay on your shelf (disk) until you need them again

The operating system tracks which files are open—leave too many open without closing, and you'll run out of "hands" to hold them (file descriptors).

---

## The Technical Reality

### File Handles and Resources

When you open a file, Python asks the operating system for a **file handle**—a connection to the file. This is a limited resource:

~~~python runnable
# The OS gives you a file handle
f = open("data.txt", "r")
# ... use the file ...
f.close()  # Release the handle back to the OS
~~~

If you forget `close()`, you risk:
- Running out of file handles (OS limit)
- Data not being written (buffered in memory)
- File locks preventing other programs from accessing it

### The `with` Statement

Python's context manager ensures files are closed even if errors occur:

~~~python runnable
# ALWAYS use this pattern
with open("data.txt", "r") as f:
    content = f.read()
# File is automatically closed here, even if an exception occurred
~~~

---

## The Code

### Reading Files

~~~python runnable
# Read entire file as string
with open("prices.txt", "r") as f:
    content = f.read()
print(content)

# Read line by line (memory efficient for large files)
with open("prices.txt", "r") as f:
    for line in f:
        print(line.strip())  # strip() removes trailing newline

# Read all lines into a list
with open("prices.txt", "r") as f:
    lines = f.readlines()
# ['line1\n', 'line2\n', ...]

# Read specific number of characters
with open("data.txt", "r") as f:
    chunk = f.read(100)  # First 100 characters
~~~

### Writing Files

~~~python runnable
# Write (creates new or overwrites existing)
with open("output.txt", "w") as f:
    f.write("Hello, World!\n")
    f.write("Second line\n")

# Append (adds to end of existing file)
with open("log.txt", "a") as f:
    f.write("New log entry\n")

# Write multiple lines
lines = ["line 1", "line 2", "line 3"]
with open("output.txt", "w") as f:
    for line in lines:
        f.write(line + "\n")
    # Or: f.writelines(line + "\n" for line in lines)
~~~

### File Modes

~~~python runnable
"r"   # Read (default). Error if file doesn't exist
"w"   # Write. Creates new file or truncates existing
"a"   # Append. Creates new file or adds to end
"x"   # Exclusive create. Error if file exists
"r+"  # Read and write
"w+"  # Write and read (truncates)
"a+"  # Append and read

# Add 'b' for binary mode
"rb"  # Read binary (images, etc.)
"wb"  # Write binary
~~~

### Working with CSV Files

~~~python runnable
import csv

# Writing CSV
stocks = [
    ["Symbol", "Price", "Shares"],
    ["AAPL", 175.50, 100],
    ["GOOGL", 140.25, 50],
]

with open("portfolio.csv", "w", newline="") as f:
    writer = csv.writer(f)
    writer.writerows(stocks)

# Reading CSV
with open("portfolio.csv", "r") as f:
    reader = csv.reader(f)
    header = next(reader)  # Skip header row
    for row in reader:
        symbol, price, shares = row
        print(f"{symbol}: {shares} shares @ ${price}")

# CSV with dictionaries (recommended)
stocks = [
    {"symbol": "AAPL", "price": 175.50, "shares": 100},
    {"symbol": "GOOGL", "price": 140.25, "shares": 50},
]

with open("portfolio.csv", "w", newline="") as f:
    writer = csv.DictWriter(f, fieldnames=["symbol", "price", "shares"])
    writer.writeheader()
    writer.writerows(stocks)

with open("portfolio.csv", "r") as f:
    reader = csv.DictReader(f)
    for row in reader:
        print(row)  # {"symbol": "AAPL", "price": "175.50", "shares": "100"}
        # Note: values are strings! Convert as needed
~~~

### Working with JSON

~~~python runnable
import json

# Python object to JSON file
portfolio = {
    "name": "Growth Portfolio",
    "cash": 10000,
    "holdings": [
        {"symbol": "AAPL", "shares": 100},
        {"symbol": "GOOGL", "shares": 50}
    ]
}

with open("portfolio.json", "w") as f:
    json.dump(portfolio, f, indent=2)  # indent for pretty printing

# JSON file to Python object
with open("portfolio.json", "r") as f:
    loaded = json.load(f)
print(loaded["holdings"][0]["symbol"])  # "AAPL"

# JSON string conversion
json_str = json.dumps(portfolio)       # Object to string
obj = json.loads(json_str)             # String to object
~~~

### Path Operations

~~~python runnable
from pathlib import Path

# Modern path handling (recommended)
data_dir = Path("data")
file_path = data_dir / "prices.csv"  # data/prices.csv

# Check if exists
if file_path.exists():
    print("File found")

if data_dir.is_dir():
    print("Directory found")

# Create directories
data_dir.mkdir(exist_ok=True)  # No error if exists
data_dir.mkdir(parents=True, exist_ok=True)  # Create parent dirs too

# List files in directory
for file in data_dir.glob("*.csv"):
    print(file.name)

# File properties
print(file_path.name)       # "prices.csv"
print(file_path.stem)       # "prices"
print(file_path.suffix)     # ".csv"
print(file_path.parent)     # "data"

# Read/write with Path
content = file_path.read_text()
file_path.write_text("new content")
~~~

---

## The Exercise

### Exercise 1.1: Stock Price Logger
~~~python exercise id="3.1.1"
# Create a program that:
# 1. Reads a list of stock prices from a CSV file
# 2. Calculates daily returns
# 3. Writes the results to a new CSV file with columns:
#    date, price, daily_return

# Sample input (prices.csv):
# date,price
# 2024-01-01,150.00
# 2024-01-02,152.50
# 2024-01-03,151.00
~~~

### Exercise 1.2: Portfolio Persistence
~~~python exercise id="3.1.2"
# Extend the Portfolio class to save/load from JSON:

class Portfolio:
    def save(self, filepath: str):
        """Save portfolio to JSON file."""
        pass

    @classmethod
    def load(cls, filepath: str) -> 'Portfolio':
        """Load portfolio from JSON file."""
        pass
~~~

### Exercise 1.3: Log File Analyzer
~~~python exercise id="3.1.3"
# Given a log file with entries like:
# 2024-01-15 10:30:45 INFO  User login: john
# 2024-01-15 10:31:02 ERROR Database connection failed
# 2024-01-15 10:31:15 INFO  Retry successful

# Parse the file and create a summary:
# - Total entries
# - Count by log level (INFO, ERROR, etc.)
# - First and last timestamp
~~~

---

## The Gotchas

### Gotcha 1: Forgetting to Close Files

```python
# BAD - file might not close on error
f = open("data.txt")
process(f.read())
f.close()  # Never reached if process() raises!

# GOOD - always closes
with open("data.txt") as f:
    process(f.read())
```

### Gotcha 2: File Encoding

```python
# Default encoding varies by OS!
# Always specify encoding for text files:
with open("data.txt", "r", encoding="utf-8") as f:
    content = f.read()
```

### Gotcha 3: Newlines in CSV

```python
# On Windows, CSV can have extra blank lines
# Always use newline="" with csv module:
with open("data.csv", "w", newline="") as f:
    writer = csv.writer(f)
```

### Gotcha 4: JSON Limitations

```python
# JSON can't serialize everything
import json
from datetime import datetime

data = {"timestamp": datetime.now()}
json.dumps(data)  # TypeError: datetime is not JSON serializable

# Solution: convert to string
data = {"timestamp": datetime.now().isoformat()}
```

---

## Key Takeaways

1. Always use `with` statement for file operations
2. Choose the right mode: `r` (read), `w` (write), `a` (append)
3. Use `csv` module for CSV files, `json` module for JSON
4. Use `pathlib.Path` for modern path handling
5. Always specify `encoding="utf-8"` for text files
6. Remember: CSV values are strings—convert types manually

---

## Next Lesson

Files are great for local storage. But programs can fail in unexpected ways. Next: **HTTP and APIs**—interacting with the web.
