---
title: "Testing"
phase: 3
order: 6
requires: ["pytest"]
prev: "3.5_debugging"
next: "3.7_project_stock_fetcher"
---

# Lesson 6: Testing

> **Note:** This platform supports `assert` statements. Full `pytest` integration requires a local environment, but the principles are the same.

## The Problem

You wrote a function. You ran it once with `x=10`, and it worked. You assume it's perfect. Two weeks later, you change a line of code, and suddenly that function breaksâ€”but you don't notice until a customer complains.

You need a way to **automatically verify** that your code still works every time you make a change.

---

## The Metaphor

Testing is like **double-entry bookkeeping** in accounting, or a **safety inspection** for a car.

- You don't just "drive the car" to see if the brakes work. You put it on a stand and measure the brake force against a known standard.
- **Unit Tests** inspect individual parts (does the spark plug spark?).
- **Integration Tests** inspect how parts work together (does the engine start when I turn the key?).

---

## The Technical Reality

### The `assert` statement

Python has a built-in keyword `assert`.
- If the condition is True, nothing happens.
- If the condition is False, it raises an `AssertionError`.

~~~python runnable
x = 10
assert x == 10  # Silence is golden
# assert x == 5   # Crash! AssertionError
print("Assertions passed")
~~~

### `pytest`

While you can use `assert` manually, professionals use a framework called **pytest**. It finds all your tests and runs them for you.

To use it:
1.  `pip install pytest`
2.  Create a file starting with `test_` (e.g., `test_calc.py`).
3.  Write functions starting with `test_`.
4.  Run `pytest` in the terminal.

---

## The Code

### Writing a Test

Suppose you have this code in `calc.py`:

```python
def add(a, b):
    return a + b

def divide(a, b):
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b
```

You write this test file `test_calc.py`:

```python
from calc import add, divide
import pytest

def test_add_simple():
    assert add(2, 3) == 5

def test_add_negative():
    assert add(-1, 1) == 0

def test_divide_simple():
    assert divide(10, 2) == 5

def test_divide_zero():
    # We expect a ValueError here
    with pytest.raises(ValueError):
        divide(10, 0)
```

### Running Tests

In the terminal:
```bash
pytest
```

Output:
```text
test_calc.py ....                                       [100%]
4 passed in 0.01s
```

The dots `....` mean 4 tests passed. If one failed, you'd see an `F` and a detailed report of why.

---

## The Exercise

### Exercise 3.6: Write Your First Test

We have a function `calculate_profit`. Write tests to verify it works.

1.  Test a standard case (profit).
2.  Test a loss case (negative profit).
3.  Test the breakeven case (0).

~~~python exercise id="3.6"
def calculate_profit(revenue, expenses):
    return revenue - expenses

# Write your assertions below
# assert calculate_profit(100, 80) == ...
~~~

---

## The Gotchas

### Gotcha 1: Testing the Trivial
Don't test `1 + 1 == 2`. Test your **logic**.
*Bad*: `assert list.append(1)` works.
*Good*: `assert my_complex_sort_function()` works.

### Gotcha 2: Flaky Tests
Tests should be deterministic. If a test passes 90% of the time (e.g., because it relies on a random number or a network call), it's a bad test.
*Fix*: Use "mocking" (advanced topic) to fake random/network behavior.

### Gotcha 3: Test Discovery
`pytest` only looks for files named `test_*.py` or `*_test.py`. If you name your file `my_tests.py`, it won't find it!

---

## Key Takeaways

1.  **Tests save time**. They catch bugs *before* you commit code.
2.  Use **`pytest`**. It's the industry standard.
3.  **`assert`** is your main tool.
4.  Test **edge cases** (0, negative numbers, empty lists), not just the "happy path".

---

## Next Lesson

You now have a full professional toolkit: Modules, Venvs, Debugging, and Testing. Time to apply all of this to a robust project: **Project: Stock Price Fetcher** (Revised).
