---
title: "NumPy"
phase: 4
order: 1
requires: ["numpy"]
prev: "3.2_apis"
next: "4.2_pandas"
---

# Lesson 1: NumPy Fundamentals

## The Problem

You have 10 million stock prices. A Python list would work, but operations are slow—Python loops check types and handle exceptions for every single element. For numerical computing, you need something built for speed.

---

## The Metaphor

**Python lists** are like a **warehouse of mixed boxes**. Each box might contain anything—a number, a string, a cat. To process them, a worker must open each box, check what's inside, decide what to do, and handle surprises.

**NumPy arrays** are like a **warehouse of identical pallets**. Every pallet holds the same type of item, organized in a perfect grid. Machines can process thousands of pallets simultaneously without stopping to inspect each one.

---

## The Technical Reality

### Why NumPy Is Fast

1. **Homogeneous data**: All elements are the same type (stored efficiently in contiguous memory)
2. **Vectorization**: Operations happen in optimized C code, not Python loops
3. **Broadcasting**: Operations automatically expand to match array shapes
4. **SIMD instructions**: CPU can process multiple elements simultaneously

~~~python runnable
import numpy as np

# Python list - slow
prices_list = list(range(1000000))
returns_list = [(prices_list[i] - prices_list[i-1]) / prices_list[i-1]
                for i in range(1, len(prices_list))]

# NumPy array - fast (100x or more)
prices_array = np.arange(1000000)
returns_array = np.diff(prices_array) / prices_array[:-1]
~~~

### Memory Layout

```
Python list (pointers to objects scattered in memory):
[ptr1] → [PyObject: 100]
[ptr2] → [PyObject: 200]
[ptr3] → [PyObject: 300]

NumPy array (contiguous block of raw values):
[100|200|300|400|500|...]  ← All values packed together
```

---

## The Code

### Creating Arrays

~~~python runnable
import numpy as np

# From Python list
prices = np.array([100, 150, 125, 175])

# Specify dtype
prices = np.array([100, 150, 125], dtype=np.float64)

# Zeros, ones, empty
zeros = np.zeros(10)           # [0. 0. 0. ... 0.]
ones = np.ones(10)             # [1. 1. 1. ... 1.]
empty = np.empty(10)           # Uninitialized (fast, contains garbage)
full = np.full(10, 3.14)       # [3.14 3.14 3.14 ...]

# Range-like functions
a = np.arange(0, 10, 2)        # [0 2 4 6 8]
b = np.linspace(0, 1, 5)       # [0. 0.25 0.5 0.75 1.] (5 evenly spaced)

# Random numbers
rand = np.random.rand(10)              # Uniform [0, 1)
randn = np.random.randn(10)            # Normal distribution
randint = np.random.randint(0, 100, 10) # Random integers

# Multi-dimensional
matrix = np.zeros((3, 4))      # 3 rows, 4 columns
tensor = np.zeros((2, 3, 4))   # 2x3x4 3D array

# Identity matrix
eye = np.eye(3)
# [[1. 0. 0.]
#  [0. 1. 0.]
#  [0. 0. 1.]]
~~~

### Array Properties

~~~python runnable
prices = np.array([[100, 150, 125], [200, 175, 225]])

prices.shape    # (2, 3) - 2 rows, 3 columns
prices.ndim     # 2 - number of dimensions
prices.size     # 6 - total elements
prices.dtype    # float64 - data type
prices.nbytes   # 48 - memory used (6 * 8 bytes)
~~~

### Indexing and Slicing

~~~python runnable
prices = np.array([100, 150, 125, 175, 200])

# Basic indexing (same as lists)
prices[0]       # 100
prices[-1]      # 200
prices[1:4]     # array([150, 125, 175])

# Boolean indexing (powerful!)
mask = prices > 150
print(mask)           # [False False False  True  True]
print(prices[mask])   # [175, 200]

# Shorthand
prices[prices > 150]  # [175, 200]

# Fancy indexing (select specific indices)
indices = [0, 2, 4]
prices[indices]       # [100, 125, 200]

# 2D indexing
matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
matrix[0, 0]          # 1 (row 0, col 0)
matrix[0, :]          # [1, 2, 3] (entire row 0)
matrix[:, 0]          # [1, 4, 7] (entire column 0)
matrix[1:, 1:]        # [[5, 6], [8, 9]] (bottom-right 2x2)
~~~

### Vectorized Operations

~~~python runnable
prices = np.array([100, 150, 125, 175])

# Arithmetic on all elements at once
prices * 2            # [200 300 250 350]
prices + 10           # [110 160 135 185]
prices ** 2           # [10000 22500 15625 30625]

# Array-to-array operations
costs = np.array([90, 120, 100, 150])
profits = prices - costs  # [10 30 25 25]
returns = (prices - costs) / costs  # [0.111 0.25 0.25 0.167]

# Comparison (returns boolean array)
prices > 130          # [False  True False  True]

# Mathematical functions
np.sqrt(prices)       # [10. 12.25 11.18 13.23]
np.log(prices)        # [4.61 5.01 4.83 5.16]
np.exp(prices)        # Very large numbers!
~~~

### Aggregation

~~~python runnable
prices = np.array([100, 150, 125, 175, 200])

np.sum(prices)        # 750
np.mean(prices)       # 150.0
np.std(prices)        # 35.36 (standard deviation)
np.var(prices)        # 1250.0 (variance)
np.min(prices)        # 100
np.max(prices)        # 200
np.argmin(prices)     # 0 (index of minimum)
np.argmax(prices)     # 4 (index of maximum)

# 2D aggregation
matrix = np.array([[1, 2, 3], [4, 5, 6]])

np.sum(matrix)           # 21 (all elements)
np.sum(matrix, axis=0)   # [5, 7, 9] (sum each column)
np.sum(matrix, axis=1)   # [6, 15] (sum each row)
~~~

### Reshaping

~~~python runnable
a = np.arange(12)
# [0 1 2 3 4 5 6 7 8 9 10 11]

# Reshape to 3x4
b = a.reshape(3, 4)
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]]

# Reshape with -1 (infer dimension)
c = a.reshape(4, -1)  # 4 rows, auto-calculate columns → 4x3
c = a.reshape(-1, 2)  # 2 columns, auto-calculate rows → 6x2

# Flatten (back to 1D)
d = b.flatten()       # [0 1 2 3 4 5 6 7 8 9 10 11]

# Transpose
e = b.T               # 4x3 matrix
~~~

### Broadcasting

NumPy automatically expands arrays to compatible shapes:

~~~python runnable
# Scalar broadcast
a = np.array([1, 2, 3])
a * 2                 # [2, 4, 6] - 2 "broadcast" to [2, 2, 2]

# 1D to 2D broadcast
matrix = np.array([[1, 2, 3], [4, 5, 6]])  # 2x3
row = np.array([10, 20, 30])               # 1x3

matrix + row
# [[11 22 33]
#  [14 25 36]]
# row is "broadcast" to each row of matrix
~~~

---

## The Exercise

### Exercise 1.1: Calculate Returns
~~~python exercise id="4.1.1"
# Given daily closing prices, calculate:
# 1. Daily returns: (price[i] - price[i-1]) / price[i-1]
# 2. Cumulative returns: total growth from day 1
# 3. Maximum drawdown: largest peak-to-trough decline

prices = np.array([100, 102, 98, 105, 110, 108, 115, 112, 120, 118])

# Hint for returns: np.diff(prices) gives differences
# Hint for cumulative: np.cumprod() for cumulative product
~~~

### Exercise 1.2: Portfolio Statistics
~~~python exercise id="4.1.2"
# Given 4 stocks' daily returns (rows=stocks, cols=days)
returns = np.array([
    [0.01, -0.02, 0.015, 0.008, -0.005],   # AAPL
    [0.02, -0.01, 0.01, -0.015, 0.025],    # GOOGL
    [-0.005, 0.03, -0.01, 0.02, 0.01],     # MSFT
    [0.015, 0.01, 0.02, -0.01, 0.005],     # AMZN
])

# Calculate:
# 1. Mean return for each stock
# 2. Volatility (std) for each stock
# 3. Correlation matrix between stocks
# 4. Sharpe ratio (mean / std) for each stock
~~~

### Exercise 1.3: Moving Average
~~~python exercise id="4.1.3"
def moving_average(prices: np.ndarray, window: int) -> np.ndarray:
    """
    Calculate simple moving average.

    Returns array of length (len(prices) - window + 1)
    """
    pass

# Test:
prices = np.array([100, 102, 104, 103, 105, 108, 110, 109, 111, 115])
ma5 = moving_average(prices, 5)
# Should be: [102.8, 104.4, 106.0, 107.0, 108.6, 110.6]
~~~

---

## The Gotchas

### Gotcha 1: Views vs Copies

```python
a = np.array([1, 2, 3, 4, 5])
b = a[2:4]       # This is a VIEW, not a copy!
b[0] = 999
print(a)         # [1 2 999 4 5] - a changed!

# Explicit copy
b = a[2:4].copy()
b[0] = 999
print(a)         # [1 2 3 4 5] - a unchanged
```

### Gotcha 2: Integer Division

```python
a = np.array([1, 2, 3])
b = a / 2        # [0.5, 1.0, 1.5] - float division

a = np.array([1, 2, 3], dtype=np.int32)
b = a / 2        # [0.5, 1.0, 1.5] - still float (/ always returns float)
b = a // 2       # [0, 1, 1] - integer division
```

### Gotcha 3: Boolean Indexing Creates Copy

```python
a = np.array([1, 2, 3, 4, 5])
b = a[a > 2]     # This IS a copy
b[0] = 999
print(a)         # [1 2 3 4 5] - unchanged!

# To modify original, assign back
a[a > 2] = 0     # [1 2 0 0 0]
```

---

## Key Takeaways

1. NumPy arrays are fast because they're contiguous and typed
2. Avoid Python loops—use vectorized operations
3. Boolean indexing is powerful for filtering
4. Aggregations take `axis` parameter for row/column operations
5. Broadcasting automatically expands arrays to compatible shapes
6. Slicing creates views, not copies (be careful!)

---

## Next Lesson

NumPy is the foundation. Now build on it with **pandas**—the essential tool for tabular data like stock prices with dates.
